<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Max 6 API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
</head>
<body>
<div id="top"><!-- do not remove this div! -->
<div id="titlearea">
	<div id="c74header">
		<img src="header.png" height="100" />
	</div>
</div>
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__memory.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Memory Management</div>  </div>
</div><!--header-->
<div class="contents">

<p>In the past, Max has provided two separate APIs for memory management.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga6ae185a510cc76224680e6156b843055"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga6ae185a510cc76224680e6156b843055">MM_UNIFIED</a></td></tr>
<tr class="memdesc:ga6ae185a510cc76224680e6156b843055"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro being defined means that getbytes and sysmem APIs for memory management are unified.  <a href="#ga6ae185a510cc76224680e6156b843055">More...</a><br /></td></tr>
<tr class="separator:ga6ae185a510cc76224680e6156b843055"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad4269b29be988878da2d8d5579696d60"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#gad4269b29be988878da2d8d5579696d60">getbytes</a> (<a class="el" href="group__misc.html#ga399f0cab8235c1b1cf9208900f25e4a5">t_getbytes_size</a> size)</td></tr>
<tr class="memdesc:gad4269b29be988878da2d8d5579696d60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate small amounts of non-relocatable memory.  <a href="#gad4269b29be988878da2d8d5579696d60">More...</a><br /></td></tr>
<tr class="separator:gad4269b29be988878da2d8d5579696d60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5520eadf3494221726cfaf3cbd35f8e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga5520eadf3494221726cfaf3cbd35f8e9">freebytes</a> (void *b, <a class="el" href="group__misc.html#ga399f0cab8235c1b1cf9208900f25e4a5">t_getbytes_size</a> size)</td></tr>
<tr class="memdesc:ga5520eadf3494221726cfaf3cbd35f8e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free memory allocated with <a class="el" href="group__memory.html#gad4269b29be988878da2d8d5579696d60" title="Allocate small amounts of non-relocatable memory. ">getbytes()</a>.  <a href="#ga5520eadf3494221726cfaf3cbd35f8e9">More...</a><br /></td></tr>
<tr class="separator:ga5520eadf3494221726cfaf3cbd35f8e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b3c29bac42419b0fe1ad954029a2179"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga2b3c29bac42419b0fe1ad954029a2179">getbytes16</a> (<a class="el" href="group__misc.html#ga399f0cab8235c1b1cf9208900f25e4a5">t_getbytes_size</a> size)</td></tr>
<tr class="memdesc:ga2b3c29bac42419b0fe1ad954029a2179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use <a class="el" href="group__memory.html#ga2b3c29bac42419b0fe1ad954029a2179" title="Use getbytes16() to allocate small amounts of non-relocatable memory that is aligned on a 16-byte bou...">getbytes16()</a> to allocate small amounts of non-relocatable memory that is aligned on a 16-byte boundary for use with vector optimization.  <a href="#ga2b3c29bac42419b0fe1ad954029a2179">More...</a><br /></td></tr>
<tr class="separator:ga2b3c29bac42419b0fe1ad954029a2179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3943682e8f9813a8fe4f8d407a32ac9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#gad3943682e8f9813a8fe4f8d407a32ac9">freebytes16</a> (char *mem, <a class="el" href="group__misc.html#ga399f0cab8235c1b1cf9208900f25e4a5">t_getbytes_size</a> size)</td></tr>
<tr class="memdesc:gad3943682e8f9813a8fe4f8d407a32ac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free memory allocated with <a class="el" href="group__memory.html#ga2b3c29bac42419b0fe1ad954029a2179" title="Use getbytes16() to allocate small amounts of non-relocatable memory that is aligned on a 16-byte bou...">getbytes16()</a>.  <a href="#gad3943682e8f9813a8fe4f8d407a32ac9">More...</a><br /></td></tr>
<tr class="separator:gad3943682e8f9813a8fe4f8d407a32ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50135e5f9bb18030ff1d12e9976253ab"><td class="memItemLeft" align="right" valign="top">char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga50135e5f9bb18030ff1d12e9976253ab">newhandle</a> (long size)</td></tr>
<tr class="memdesc:ga50135e5f9bb18030ff1d12e9976253ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate relocatable memory.  <a href="#ga50135e5f9bb18030ff1d12e9976253ab">More...</a><br /></td></tr>
<tr class="separator:ga50135e5f9bb18030ff1d12e9976253ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6402eb4bbf3acd03d3e2f1133195bac3"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga6402eb4bbf3acd03d3e2f1133195bac3">growhandle</a> (void *h, long size)</td></tr>
<tr class="memdesc:ga6402eb4bbf3acd03d3e2f1133195bac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the size of a handle.  <a href="#ga6402eb4bbf3acd03d3e2f1133195bac3">More...</a><br /></td></tr>
<tr class="separator:ga6402eb4bbf3acd03d3e2f1133195bac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae325435a83824eb6b42e0885b68b9110"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#gae325435a83824eb6b42e0885b68b9110">disposhandle</a> (char **h)</td></tr>
<tr class="memdesc:gae325435a83824eb6b42e0885b68b9110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the memory used by a handle you no longer need.  <a href="#gae325435a83824eb6b42e0885b68b9110">More...</a><br /></td></tr>
<tr class="separator:gae325435a83824eb6b42e0885b68b9110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6d2540a14c12af221770c2793775a89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__misc.html#ga06f35de4fc025809ab1cbb06f55b6495">BEGIN_USING_C_LINKAGE</a> <a class="el" href="group__misc.html#ga70766a030fcd392d4574fa59b296a68e">t_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#gad6d2540a14c12af221770c2793775a89">sysmem_newptr</a> (long size)</td></tr>
<tr class="memdesc:gad6d2540a14c12af221770c2793775a89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory.  <a href="#gad6d2540a14c12af221770c2793775a89">More...</a><br /></td></tr>
<tr class="separator:gad6d2540a14c12af221770c2793775a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c178a079247f715c6e34c828d375324"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__misc.html#ga70766a030fcd392d4574fa59b296a68e">t_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga1c178a079247f715c6e34c828d375324">sysmem_newptrclear</a> (long size)</td></tr>
<tr class="memdesc:ga1c178a079247f715c6e34c828d375324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory and set it to zero.  <a href="#ga1c178a079247f715c6e34c828d375324">More...</a><br /></td></tr>
<tr class="separator:ga1c178a079247f715c6e34c828d375324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacad6bca165c7b2849fc81d8449245755"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__misc.html#ga70766a030fcd392d4574fa59b296a68e">t_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#gacad6bca165c7b2849fc81d8449245755">sysmem_resizeptr</a> (void *ptr, long newsize)</td></tr>
<tr class="memdesc:gacad6bca165c7b2849fc81d8449245755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize an existing pointer.  <a href="#gacad6bca165c7b2849fc81d8449245755">More...</a><br /></td></tr>
<tr class="separator:gacad6bca165c7b2849fc81d8449245755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf458ca679d665984dbaa8125c88a417e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__misc.html#ga70766a030fcd392d4574fa59b296a68e">t_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#gaf458ca679d665984dbaa8125c88a417e">sysmem_resizeptrclear</a> (void *ptr, long newsize)</td></tr>
<tr class="memdesc:gaf458ca679d665984dbaa8125c88a417e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize an existing pointer and clear it.  <a href="#gaf458ca679d665984dbaa8125c88a417e">More...</a><br /></td></tr>
<tr class="separator:gaf458ca679d665984dbaa8125c88a417e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f847713a1bd083030d60e8752d7c28d"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga4f847713a1bd083030d60e8752d7c28d">sysmem_ptrsize</a> (void *ptr)</td></tr>
<tr class="memdesc:ga4f847713a1bd083030d60e8752d7c28d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the size of a pointer.  <a href="#ga4f847713a1bd083030d60e8752d7c28d">More...</a><br /></td></tr>
<tr class="separator:ga4f847713a1bd083030d60e8752d7c28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga200c82639e547869db1f3887d17102d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga200c82639e547869db1f3887d17102d3">sysmem_freeptr</a> (void *ptr)</td></tr>
<tr class="memdesc:ga200c82639e547869db1f3887d17102d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free memory allocated with <a class="el" href="group__memory.html#gad6d2540a14c12af221770c2793775a89" title="Allocate memory. ">sysmem_newptr()</a>.  <a href="#ga200c82639e547869db1f3887d17102d3">More...</a><br /></td></tr>
<tr class="separator:ga200c82639e547869db1f3887d17102d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga527cceb7178a110b73ca01fdc41702b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga527cceb7178a110b73ca01fdc41702b4">sysmem_copyptr</a> (const void *src, void *dst, long bytes)</td></tr>
<tr class="memdesc:ga527cceb7178a110b73ca01fdc41702b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy memory the contents of one pointer to another pointer.  <a href="#ga527cceb7178a110b73ca01fdc41702b4">More...</a><br /></td></tr>
<tr class="separator:ga527cceb7178a110b73ca01fdc41702b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdacfad4785c71dc8c4ce5d4d9714d54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__misc.html#ga0fe64aac41fd3ec071cce295a41d67ad">t_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#gacdacfad4785c71dc8c4ce5d4d9714d54">sysmem_newhandle</a> (long size)</td></tr>
<tr class="memdesc:gacdacfad4785c71dc8c4ce5d4d9714d54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a handle (a pointer to a pointer).  <a href="#gacdacfad4785c71dc8c4ce5d4d9714d54">More...</a><br /></td></tr>
<tr class="separator:gacdacfad4785c71dc8c4ce5d4d9714d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56406e70880d954e3d51b87e606c1398"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__misc.html#ga0fe64aac41fd3ec071cce295a41d67ad">t_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga56406e70880d954e3d51b87e606c1398">sysmem_newhandleclear</a> (unsigned long size)</td></tr>
<tr class="memdesc:ga56406e70880d954e3d51b87e606c1398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a handle (a pointer to a pointer) whose memory is set to zero.  <a href="#ga56406e70880d954e3d51b87e606c1398">More...</a><br /></td></tr>
<tr class="separator:ga56406e70880d954e3d51b87e606c1398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga420520dda6015ec33876b18b860083dd"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga420520dda6015ec33876b18b860083dd">sysmem_resizehandle</a> (<a class="el" href="group__misc.html#ga0fe64aac41fd3ec071cce295a41d67ad">t_handle</a> handle, long newsize)</td></tr>
<tr class="memdesc:ga420520dda6015ec33876b18b860083dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize an existing handle.  <a href="#ga420520dda6015ec33876b18b860083dd">More...</a><br /></td></tr>
<tr class="separator:ga420520dda6015ec33876b18b860083dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84cf5e5a070edef2834faf3b7beed5fe"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga84cf5e5a070edef2834faf3b7beed5fe">sysmem_handlesize</a> (<a class="el" href="group__misc.html#ga0fe64aac41fd3ec071cce295a41d67ad">t_handle</a> handle)</td></tr>
<tr class="memdesc:ga84cf5e5a070edef2834faf3b7beed5fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the size of a handle.  <a href="#ga84cf5e5a070edef2834faf3b7beed5fe">More...</a><br /></td></tr>
<tr class="separator:ga84cf5e5a070edef2834faf3b7beed5fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5815994f7d02b77c24f8c684df9acd83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga5815994f7d02b77c24f8c684df9acd83">sysmem_freehandle</a> (<a class="el" href="group__misc.html#ga0fe64aac41fd3ec071cce295a41d67ad">t_handle</a> handle)</td></tr>
<tr class="memdesc:ga5815994f7d02b77c24f8c684df9acd83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free memory allocated with <a class="el" href="group__memory.html#gacdacfad4785c71dc8c4ce5d4d9714d54" title="Allocate a handle (a pointer to a pointer). ">sysmem_newhandle()</a>.  <a href="#ga5815994f7d02b77c24f8c684df9acd83">More...</a><br /></td></tr>
<tr class="separator:ga5815994f7d02b77c24f8c684df9acd83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga545ea0e5d3d8f14bda62f8ac6b3e6d71"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga545ea0e5d3d8f14bda62f8ac6b3e6d71">sysmem_lockhandle</a> (<a class="el" href="group__misc.html#ga0fe64aac41fd3ec071cce295a41d67ad">t_handle</a> handle, long lock)</td></tr>
<tr class="memdesc:ga545ea0e5d3d8f14bda62f8ac6b3e6d71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the locked/unlocked state of a handle.  <a href="#ga545ea0e5d3d8f14bda62f8ac6b3e6d71">More...</a><br /></td></tr>
<tr class="separator:ga545ea0e5d3d8f14bda62f8ac6b3e6d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab59295d789b6a720b9ab981a39441cbc"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#gab59295d789b6a720b9ab981a39441cbc">sysmem_ptrandhand</a> (void *p, <a class="el" href="group__misc.html#ga0fe64aac41fd3ec071cce295a41d67ad">t_handle</a> h, long size)</td></tr>
<tr class="memdesc:gab59295d789b6a720b9ab981a39441cbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add memory to an existing handle and copy memory to the resized portion from a pointer.  <a href="#gab59295d789b6a720b9ab981a39441cbc">More...</a><br /></td></tr>
<tr class="separator:gab59295d789b6a720b9ab981a39441cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52dd152965c42f6b1e14cfdf8b102a30"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga52dd152965c42f6b1e14cfdf8b102a30">sysmem_ptrbeforehand</a> (void *p, <a class="el" href="group__misc.html#ga0fe64aac41fd3ec071cce295a41d67ad">t_handle</a> h, unsigned long size)</td></tr>
<tr class="memdesc:ga52dd152965c42f6b1e14cfdf8b102a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add memory to an existing handle and copy memory to the resized portion from a pointer.  <a href="#ga52dd152965c42f6b1e14cfdf8b102a30">More...</a><br /></td></tr>
<tr class="separator:ga52dd152965c42f6b1e14cfdf8b102a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d07c8171a047d92e8bd95f8bb5b2a70"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga2d07c8171a047d92e8bd95f8bb5b2a70">sysmem_nullterminatehandle</a> (<a class="el" href="group__misc.html#ga0fe64aac41fd3ec071cce295a41d67ad">t_handle</a> h)</td></tr>
<tr class="memdesc:ga2d07c8171a047d92e8bd95f8bb5b2a70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a null terminator to a handle.  <a href="#ga2d07c8171a047d92e8bd95f8bb5b2a70">More...</a><br /></td></tr>
<tr class="separator:ga2d07c8171a047d92e8bd95f8bb5b2a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>In the past, Max has provided two separate APIs for memory management. </p>
<p>One for allocating memory on the stack so that it was interrupt safe, including the <a class="el" href="group__memory.html#gad4269b29be988878da2d8d5579696d60" title="Allocate small amounts of non-relocatable memory. ">getbytes()</a> and <a class="el" href="group__memory.html#ga5520eadf3494221726cfaf3cbd35f8e9" title="Free memory allocated with getbytes(). ">freebytes()</a> functions. The other, the "sysmem" API, were for allocating memory on the heap where larger amounts of memory were needed and the code could be guaranteed to operate at non-interrupt level.</p>
<p>Many things have changed in the environment of recent operating systems (MacOS X and Windows XP/Vista), the memory routines function differently, and the scheduler is no longer directly triggered by a hardware interrupt. In Max 5, the sysmem and getbytes API's have been unified, and thus may be used interchangeably.</p>
<p>The memory management unification can be switched on and off in the header files if needed, to compile code for older versions of Max for example, by changing the use of <a class="el" href="group__memory.html#ga6ae185a510cc76224680e6156b843055" title="This macro being defined means that getbytes and sysmem APIs for memory management are unified...">MM_UNIFIED</a> in the Max headers.</p>
<h1><a class="anchor" id="The"></a>
Sysmem API</h1>
<p>The Sysmem API provides a number of utilities for allocating and managing memory. It is relatively similar to some of the Macintosh Memory Manager API, and not too different from Standard C library memory functions. It is <em>not</em> safe to mix these routines with other memory routines (e.g. don’t use malloc() to allocate a pointer, and <a class="el" href="group__memory.html#ga200c82639e547869db1f3887d17102d3" title="Free memory allocated with sysmem_newptr(). ">sysmem_freeptr()</a> to free it). </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga6ae185a510cc76224680e6156b843055"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MM_UNIFIED</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This macro being defined means that getbytes and sysmem APIs for memory management are unified. </p>
<p>This is correct for Max 5, but should be commented out when compiling for older max targets. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gae325435a83824eb6b42e0885b68b9110"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void disposhandle </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the memory used by a handle you no longer need. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>The handle to dispose. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__memory.html#ga5815994f7d02b77c24f8c684df9acd83" title="Free memory allocated with sysmem_newhandle(). ">sysmem_freehandle()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga5520eadf3494221726cfaf3cbd35f8e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freebytes </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__misc.html#ga399f0cab8235c1b1cf9208900f25e4a5">t_getbytes_size</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free memory allocated with <a class="el" href="group__memory.html#gad4269b29be988878da2d8d5579696d60" title="Allocate small amounts of non-relocatable memory. ">getbytes()</a>. </p>
<p>As of Max 5 it is unified with <a class="el" href="group__memory.html#gad6d2540a14c12af221770c2793775a89" title="Allocate memory. ">sysmem_newptr()</a>, which is the preferred method for allocating memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>A pointer to the block of memory previously allocated that you want to free. </td></tr>
    <tr><td class="paramname">size</td><td>The size the block specified (as parameter b) in bytes. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group__objectmod.html#ga62d196313913e245d4baa69ed2308f01">jit_object_exportattrs()</a>, <a class="el" href="group__objectmod.html#ga29a1be851f1e88aa459689681d8b996e">jit_object_importattrs()</a>, <a class="el" href="group__maxwrapmod.html#ga2c14234e428260001a4b5ae40eb07525">max_jit_attr_getdump()</a>, <a class="el" href="group__maxwrapmod.html#gabebaedc41e3bfef6f84d3752f619d045">max_jit_obex_gimmeback()</a>, and <a class="el" href="group__maxwrapmod.html#ga9afabd186c3db8a6b4689eae00171bcd">max_jit_obex_gimmeback_dumpout()</a>.</p>

</div>
</div>
<a class="anchor" id="gad3943682e8f9813a8fe4f8d407a32ac9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freebytes16 </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__misc.html#ga399f0cab8235c1b1cf9208900f25e4a5">t_getbytes_size</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free memory allocated with <a class="el" href="group__memory.html#ga2b3c29bac42419b0fe1ad954029a2179" title="Use getbytes16() to allocate small amounts of non-relocatable memory that is aligned on a 16-byte bou...">getbytes16()</a>. </p>
<p>As of Max 5 it is unified with <a class="el" href="group__memory.html#gad6d2540a14c12af221770c2793775a89" title="Allocate memory. ">sysmem_newptr()</a>, which is the preferred method for allocating memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>A pointer to the block of memory previously allocated that you want to free. </td></tr>
    <tr><td class="paramname">size</td><td>The size the block specified (as parameter b) in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Note that <a class="el" href="group__memory.html#gad3943682e8f9813a8fe4f8d407a32ac9" title="Free memory allocated with getbytes16(). ">freebytes16()</a> will cause memory corruption if you pass it memory that was allocated with <a class="el" href="group__memory.html#gad4269b29be988878da2d8d5579696d60" title="Allocate small amounts of non-relocatable memory. ">getbytes()</a>. Use it only with memory allocated with <a class="el" href="group__memory.html#ga2b3c29bac42419b0fe1ad954029a2179" title="Use getbytes16() to allocate small amounts of non-relocatable memory that is aligned on a 16-byte bou...">getbytes16()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="gad4269b29be988878da2d8d5579696d60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* getbytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__misc.html#ga399f0cab8235c1b1cf9208900f25e4a5">t_getbytes_size</a>&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate small amounts of non-relocatable memory. </p>
<p>As of Max 5 it is unified with <a class="el" href="group__memory.html#gad6d2540a14c12af221770c2793775a89" title="Allocate memory. ">sysmem_newptr()</a>, which is the preferred method for allocating memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size to allocate in bytes (up to 32767 bytes). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the allocated memory. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2b3c29bac42419b0fe1ad954029a2179"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* getbytes16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__misc.html#ga399f0cab8235c1b1cf9208900f25e4a5">t_getbytes_size</a>&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use <a class="el" href="group__memory.html#ga2b3c29bac42419b0fe1ad954029a2179" title="Use getbytes16() to allocate small amounts of non-relocatable memory that is aligned on a 16-byte bou...">getbytes16()</a> to allocate small amounts of non-relocatable memory that is aligned on a 16-byte boundary for use with vector optimization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size to allocate in bytes (up to 32767 bytes). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the allocated memory.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd><a class="el" href="group__memory.html#ga2b3c29bac42419b0fe1ad954029a2179" title="Use getbytes16() to allocate small amounts of non-relocatable memory that is aligned on a 16-byte bou...">getbytes16()</a> is identical to getbytes except that it returns memory that is aligned to a 16-byte boundary. This allows you to allocate storage for vector-optimized memory at interrupt level. Note that any memory allocated with <a class="el" href="group__memory.html#ga2b3c29bac42419b0fe1ad954029a2179" title="Use getbytes16() to allocate small amounts of non-relocatable memory that is aligned on a 16-byte bou...">getbytes16()</a> must be freed with <a class="el" href="group__memory.html#gad3943682e8f9813a8fe4f8d407a32ac9" title="Free memory allocated with getbytes16(). ">freebytes16()</a>, not <a class="el" href="group__memory.html#ga5520eadf3494221726cfaf3cbd35f8e9" title="Free memory allocated with getbytes(). ">freebytes()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6402eb4bbf3acd03d3e2f1133195bac3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short growhandle </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the size of a handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>The handle to resize. </td></tr>
    <tr><td class="paramname">size</td><td>The new size to allocate in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Ignored. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__memory.html#ga420520dda6015ec33876b18b860083dd" title="Resize an existing handle. ">sysmem_resizehandle()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga50135e5f9bb18030ff1d12e9976253ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char** newhandle </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate relocatable memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size to allocate in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The allocated handle. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__memory.html#gacdacfad4785c71dc8c4ce5d4d9714d54" title="Allocate a handle (a pointer to a pointer). ">sysmem_newhandle()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga527cceb7178a110b73ca01fdc41702b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sysmem_copyptr </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy memory the contents of one pointer to another pointer. </p>
<p>This function is similar to BlockMove() or memcpy(). It copies the contents of the memory from the source to the destination pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>A pointer to the memory whose bytes will be copied. </td></tr>
    <tr><td class="paramname">dst</td><td>A pointer to the memory where the data will be copied. </td></tr>
    <tr><td class="paramname">bytes</td><td>The size in bytes of the data to be copied. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group__memorymod.html#ga84ae88848dbd4c60b8e368773ac0ca92">jit_copy_bytes()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5815994f7d02b77c24f8c684df9acd83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sysmem_freehandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__misc.html#ga0fe64aac41fd3ec071cce295a41d67ad">t_handle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free memory allocated with <a class="el" href="group__memory.html#gacdacfad4785c71dc8c4ce5d4d9714d54" title="Allocate a handle (a pointer to a pointer). ">sysmem_newhandle()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle whose memory will be freed. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group__memorymod.html#ga2710dd7978b8e7f406b525261fb42346">jit_handle_free()</a>.</p>

</div>
</div>
<a class="anchor" id="ga200c82639e547869db1f3887d17102d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sysmem_freeptr </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free memory allocated with <a class="el" href="group__memory.html#gad6d2540a14c12af221770c2793775a89" title="Allocate memory. ">sysmem_newptr()</a>. </p>
<p>This function is similar to DisposePtr or free. It frees the memory that had been allocated to the given pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The pointer whose memory will be freed. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group__memorymod.html#gaa5a4969fb76823dd0c3a679a5bd01222">jit_disposeptr()</a>, <a class="el" href="group__memorymod.html#ga4a6a1b9a98f66b50735f69e6acf64af0">jit_freebytes()</a>, and <a class="el" href="group__ob3dmod.html#gafdefdd4ecd67b98eea24ede76032d4c4">jit_gl_begincapture()</a>.</p>

</div>
</div>
<a class="anchor" id="ga84cf5e5a070edef2834faf3b7beed5fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long sysmem_handlesize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__misc.html#ga0fe64aac41fd3ec071cce295a41d67ad">t_handle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the size of a handle. </p>
<p>This function is similar to GetHandleSize().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle whose size will be queried. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes allocated to the specified handle. </dd></dl>

<p>Referenced by <a class="el" href="group__memorymod.html#gac31e411720c7f4c3ed1d6d9e4bebd513">jit_handle_size_get()</a>.</p>

</div>
</div>
<a class="anchor" id="ga545ea0e5d3d8f14bda62f8ac6b3e6d71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long sysmem_lockhandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__misc.html#ga0fe64aac41fd3ec071cce295a41d67ad">t_handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the locked/unlocked state of a handle. </p>
<p>This function is similar to HLock or HUnlock. It sets the lock state of a handle, using a zero or non-zero number.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle that will be locked. </td></tr>
    <tr><td class="paramname">lock</td><td>The new lock state of the handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous lock state. </dd></dl>

<p>Referenced by <a class="el" href="group__memorymod.html#ga8beac43ecbe453e810b373739bbf1483">jit_handle_lock()</a>.</p>

</div>
</div>
<a class="anchor" id="gacdacfad4785c71dc8c4ce5d4d9714d54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__misc.html#ga0fe64aac41fd3ec071cce295a41d67ad">t_handle</a> sysmem_newhandle </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a handle (a pointer to a pointer). </p>
<p>This function is similar to NewHandle(). It allocates a handle of a given number of bytes and returns a <a class="el" href="group__misc.html#ga0fe64aac41fd3ec071cce295a41d67ad" title="a handle (address of a pointer) ">t_handle</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size of the handle in bytes that will be allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="group__misc.html#ga0fe64aac41fd3ec071cce295a41d67ad" title="a handle (address of a pointer) ">t_handle</a>. </dd></dl>

<p>Referenced by <a class="el" href="group__memorymod.html#ga09f5e82fafd1de78638c36105860a635">jit_handle_new()</a>.</p>

</div>
</div>
<a class="anchor" id="ga56406e70880d954e3d51b87e606c1398"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__misc.html#ga0fe64aac41fd3ec071cce295a41d67ad">t_handle</a> sysmem_newhandleclear </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a handle (a pointer to a pointer) whose memory is set to zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size of the handle in bytes that will be allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="group__misc.html#ga0fe64aac41fd3ec071cce295a41d67ad" title="a handle (address of a pointer) ">t_handle</a>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__memory.html#gacdacfad4785c71dc8c4ce5d4d9714d54" title="Allocate a handle (a pointer to a pointer). ">sysmem_newhandle()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gad6d2540a14c12af221770c2793775a89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__misc.html#ga06f35de4fc025809ab1cbb06f55b6495">BEGIN_USING_C_LINKAGE</a> <a class="el" href="group__misc.html#ga70766a030fcd392d4574fa59b296a68e">t_ptr</a> sysmem_newptr </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate memory. </p>
<p>This function is similar to NewPtr() or malloc(). It allocates a pointer of a given number of bytes and returns a pointer to the memory allocated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The amount of memory to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the allocated memory, or NULL if the allocation fails. </dd></dl>

<p>Referenced by <a class="el" href="group__memorymod.html#ga348f78687a0aabb79d772d633cc679cc">jit_getbytes()</a>, <a class="el" href="group__ob3dmod.html#gafdefdd4ecd67b98eea24ede76032d4c4">jit_gl_begincapture()</a>, and <a class="el" href="group__memorymod.html#ga7c7f1fc4d1e935c154eb285c9216623b">jit_newptr()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1c178a079247f715c6e34c828d375324"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__misc.html#ga70766a030fcd392d4574fa59b296a68e">t_ptr</a> sysmem_newptrclear </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate memory and set it to zero. </p>
<p>This function is similar to NewPtrClear() or calloc(). It allocates a pointer of a given number of bytes, zeroing all memory, and returns a pointer to the memory allocated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The amount of memory to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the allocated memory, or NULL if the allocation fails. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2d07c8171a047d92e8bd95f8bb5b2a70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long sysmem_nullterminatehandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__misc.html#ga0fe64aac41fd3ec071cce295a41d67ad">t_handle</a>&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a null terminator to a handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>A handle to null terminate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. </dd></dl>

</div>
</div>
<a class="anchor" id="gab59295d789b6a720b9ab981a39441cbc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long sysmem_ptrandhand </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__misc.html#ga0fe64aac41fd3ec071cce295a41d67ad">t_handle</a>&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add memory to an existing handle and copy memory to the resized portion from a pointer. </p>
<p>This function is similar to PtrAndHand(). It resizes an existing handle by adding a given number of bytes to it and copies data from a pointer into those bytes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The existing pointer whose data will be copied into the resized handle. </td></tr>
    <tr><td class="paramname">h</td><td>The handle which will be enlarged by the size of the pointer. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes that will be added to the handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes allocated to the specified handle. </dd></dl>

</div>
</div>
<a class="anchor" id="ga52dd152965c42f6b1e14cfdf8b102a30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long sysmem_ptrbeforehand </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__misc.html#ga0fe64aac41fd3ec071cce295a41d67ad">t_handle</a>&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add memory to an existing handle and copy memory to the resized portion from a pointer. </p>
<p>Unlike <a class="el" href="group__memory.html#gab59295d789b6a720b9ab981a39441cbc" title="Add memory to an existing handle and copy memory to the resized portion from a pointer. ">sysmem_ptrandhand()</a>, however, this copies the ptr before the previously exising handle data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The existing pointer whose data will be copied into the resized handle. </td></tr>
    <tr><td class="paramname">h</td><td>The handle which will be enlarged by the size of the pointer. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes that will be added to the handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4f847713a1bd083030d60e8752d7c28d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long sysmem_ptrsize </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the size of a pointer. </p>
<p>This function is similar to _msize().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The pointer whose size will be queried </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes allocated to the pointer specified. </dd></dl>

</div>
</div>
<a class="anchor" id="ga420520dda6015ec33876b18b860083dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long sysmem_resizehandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__misc.html#ga0fe64aac41fd3ec071cce295a41d67ad">t_handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>newsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize an existing handle. </p>
<p>This function is similar to SetHandleSize(). It resizes an existing handle to the size specified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle that will be resized. </td></tr>
    <tr><td class="paramname">newsize</td><td>The new size of the handle in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes allocated to the specified handle. </dd></dl>

<p>Referenced by <a class="el" href="group__memorymod.html#ga326dbdb81cd24ec26384845cd624af7b">jit_handle_size_set()</a>.</p>

</div>
</div>
<a class="anchor" id="gacad6bca165c7b2849fc81d8449245755"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__misc.html#ga70766a030fcd392d4574fa59b296a68e">t_ptr</a> sysmem_resizeptr </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>newsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize an existing pointer. </p>
<p>This function is similar to realloc(). It resizes an existing pointer and returns a new pointer to the resized memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The pointer to the memory that will be resized. </td></tr>
    <tr><td class="paramname">newsize</td><td>The new size of the pointer in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the resized memory, or NULL if the allocation fails. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf458ca679d665984dbaa8125c88a417e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__misc.html#ga70766a030fcd392d4574fa59b296a68e">t_ptr</a> sysmem_resizeptrclear </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>newsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize an existing pointer and clear it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The pointer to the memory that will be resized. </td></tr>
    <tr><td class="paramname">newsize</td><td>The new size of the pointer in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the resized memory, or NULL if the allocation fails. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
		<div id="c74footer">
			&nbsp;&nbsp;Copyright &copy; 2013, <a href="http://www.cycling74.com/">Cycling '74</a>
		</div>
	</body>
</html>
