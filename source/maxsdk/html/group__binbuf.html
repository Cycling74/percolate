<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Max 6 API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
</head>
<body>
<div id="top"><!-- do not remove this div! -->
<div id="titlearea">
	<div id="c74header">
		<img src="header.png" height="100" />
	</div>
</div>
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__binbuf.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Binbufs<div class="ingroups"><a class="el" href="group__datatypes.html">Data Types</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>You wonâ€™t need to know about the internal structure of a Binbuf, so you can use the void * type to refer to one.  
<a href="#details">More...</a></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Collaboration diagram for Binbufs:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<center><table><tr><td><img src="group__binbuf.png" border="0" alt="" usemap="#group____binbuf"/>
<map name="group____binbuf" id="group____binbuf">
<area shape="rect" id="node2" href="group__datatypes.html" title="Data Types" alt="" coords="5,5,94,31"/></map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga4a6b741be0bee8626b4cb25baa453060"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__binbuf.html#ga4a6b741be0bee8626b4cb25baa453060">binbuf_new</a> (void)</td></tr>
<tr class="memdesc:ga4a6b741be0bee8626b4cb25baa453060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use <a class="el" href="group__binbuf.html#ga4a6b741be0bee8626b4cb25baa453060" title="Use binbuf_new() to create and initialize a Binbuf. ">binbuf_new()</a> to create and initialize a Binbuf.  <a href="#ga4a6b741be0bee8626b4cb25baa453060">More...</a><br /></td></tr>
<tr class="separator:ga4a6b741be0bee8626b4cb25baa453060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bc71e59211549a9927754452b2d9e21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__binbuf.html#ga8bc71e59211549a9927754452b2d9e21">binbuf_vinsert</a> (void *x, char *fmt,...)</td></tr>
<tr class="memdesc:ga8bc71e59211549a9927754452b2d9e21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use <a class="el" href="group__binbuf.html#ga8bc71e59211549a9927754452b2d9e21" title="Use binbuf_vinsert() to append a Max message to a Binbuf adding a semicolon. ">binbuf_vinsert()</a> to append a Max message to a Binbuf adding a semicolon.  <a href="#ga8bc71e59211549a9927754452b2d9e21">More...</a><br /></td></tr>
<tr class="separator:ga8bc71e59211549a9927754452b2d9e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8f2272c95a8e89f22f1a9c67272af5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__binbuf.html#gad8f2272c95a8e89f22f1a9c67272af5e">binbuf_insert</a> (void *x, <a class="el" href="structt__symbol.html">t_symbol</a> *s, short argc, <a class="el" href="structt__atom.html">t_atom</a> *argv)</td></tr>
<tr class="memdesc:gad8f2272c95a8e89f22f1a9c67272af5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use <a class="el" href="group__binbuf.html#gad8f2272c95a8e89f22f1a9c67272af5e" title="Use binbuf_insert() to append a Max message to a Binbuf adding a semicolon. ">binbuf_insert()</a> to append a Max message to a Binbuf adding a semicolon.  <a href="#gad8f2272c95a8e89f22f1a9c67272af5e">More...</a><br /></td></tr>
<tr class="separator:gad8f2272c95a8e89f22f1a9c67272af5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90c960507452ce76428d87c0714f9f0e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__binbuf.html#ga90c960507452ce76428d87c0714f9f0e">binbuf_eval</a> (void *x, short ac, <a class="el" href="structt__atom.html">t_atom</a> *av, void *to)</td></tr>
<tr class="memdesc:ga90c960507452ce76428d87c0714f9f0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use binbuf_eval to evaluate a Max message in a Binbuf, passing it arguments.  <a href="#ga90c960507452ce76428d87c0714f9f0e">More...</a><br /></td></tr>
<tr class="separator:ga90c960507452ce76428d87c0714f9f0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0eccee2d50ae561c625cc97238f1e21a"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__binbuf.html#ga0eccee2d50ae561c625cc97238f1e21a">binbuf_getatom</a> (void *x, long *p1, long *p2, <a class="el" href="structt__atom.html">t_atom</a> *ap)</td></tr>
<tr class="memdesc:ga0eccee2d50ae561c625cc97238f1e21a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use binbuf_getatom to retrieve a single <a class="el" href="structt__atom.html" title="An atom is a typed datum. ">t_atom</a> from a Binbuf.  <a href="#ga0eccee2d50ae561c625cc97238f1e21a">More...</a><br /></td></tr>
<tr class="separator:ga0eccee2d50ae561c625cc97238f1e21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a582c876ee074505762b30c7eef6504"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__binbuf.html#ga7a582c876ee074505762b30c7eef6504">binbuf_text</a> (void *x, char **srcText, long n)</td></tr>
<tr class="memdesc:ga7a582c876ee074505762b30c7eef6504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use <a class="el" href="group__binbuf.html#ga7a582c876ee074505762b30c7eef6504" title="Use binbuf_text() to convert a text handle to a Binbuf. ">binbuf_text()</a> to convert a text handle to a Binbuf.  <a href="#ga7a582c876ee074505762b30c7eef6504">More...</a><br /></td></tr>
<tr class="separator:ga7a582c876ee074505762b30c7eef6504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf86f516fd1846864d5226f302857e533"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__binbuf.html#gaf86f516fd1846864d5226f302857e533">binbuf_totext</a> (void *x, char **dstText, <a class="el" href="group__misc.html#gabf342d55302cfc673a3b6b14e583e3cd">t_ptr_size</a> *sizep)</td></tr>
<tr class="memdesc:gaf86f516fd1846864d5226f302857e533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use <a class="el" href="group__binbuf.html#gaf86f516fd1846864d5226f302857e533" title="Use binbuf_totext() to convert a Binbuf into a text handle. ">binbuf_totext()</a> to convert a Binbuf into a text handle.  <a href="#gaf86f516fd1846864d5226f302857e533">More...</a><br /></td></tr>
<tr class="separator:gaf86f516fd1846864d5226f302857e533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga716d66a159b96b7b9d87baaab33367e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__binbuf.html#ga716d66a159b96b7b9d87baaab33367e0">binbuf_set</a> (void *x, <a class="el" href="structt__symbol.html">t_symbol</a> *s, short argc, <a class="el" href="structt__atom.html">t_atom</a> *argv)</td></tr>
<tr class="memdesc:ga716d66a159b96b7b9d87baaab33367e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use <a class="el" href="group__binbuf.html#ga716d66a159b96b7b9d87baaab33367e0" title="Use binbuf_set() to change the entire contents of a Binbuf. ">binbuf_set()</a> to change the entire contents of a Binbuf.  <a href="#ga716d66a159b96b7b9d87baaab33367e0">More...</a><br /></td></tr>
<tr class="separator:ga716d66a159b96b7b9d87baaab33367e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57f584204ff1860c93ca728ca991fb15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__binbuf.html#ga57f584204ff1860c93ca728ca991fb15">binbuf_append</a> (void *x, <a class="el" href="structt__symbol.html">t_symbol</a> *s, short argc, <a class="el" href="structt__atom.html">t_atom</a> *argv)</td></tr>
<tr class="memdesc:ga57f584204ff1860c93ca728ca991fb15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use binbuf_append to append t_atoms to a Binbuf without modifying them.  <a href="#ga57f584204ff1860c93ca728ca991fb15">More...</a><br /></td></tr>
<tr class="separator:ga57f584204ff1860c93ca728ca991fb15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb42118a4da090a6d47954f8b299de46"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__binbuf.html#gacb42118a4da090a6d47954f8b299de46">readatom</a> (char *outstr, char **text, long *n, long e, <a class="el" href="structt__atom.html">t_atom</a> *ap)</td></tr>
<tr class="memdesc:gacb42118a4da090a6d47954f8b299de46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use <a class="el" href="group__binbuf.html#gacb42118a4da090a6d47954f8b299de46" title="Use readatom() to read a single t_atom from a text buffer. ">readatom()</a> to read a single <a class="el" href="structt__atom.html" title="An atom is a typed datum. ">t_atom</a> from a text buffer.  <a href="#gacb42118a4da090a6d47954f8b299de46">More...</a><br /></td></tr>
<tr class="separator:gacb42118a4da090a6d47954f8b299de46"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>You wonâ€™t need to know about the internal structure of a Binbuf, so you can use the void * type to refer to one. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga57f584204ff1860c93ca728ca991fb15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void binbuf_append </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt__symbol.html">t_symbol</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt__atom.html">t_atom</a> *&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use binbuf_append to append t_atoms to a Binbuf without modifying them. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Binbuf to receive the items. </td></tr>
    <tr><td class="paramname">s</td><td>Ignored. Pass NULL. </td></tr>
    <tr><td class="paramname">argc</td><td>Count of items in the argv array. </td></tr>
    <tr><td class="paramname">argv</td><td>Array of atoms to add to the Binbuf. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga90c960507452ce76428d87c0714f9f0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* binbuf_eval </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>ac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt__atom.html">t_atom</a> *&#160;</td>
          <td class="paramname"><em>av</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use binbuf_eval to evaluate a Max message in a Binbuf, passing it arguments. </p>
<p><a class="el" href="group__binbuf.html#ga90c960507452ce76428d87c0714f9f0e" title="Use binbuf_eval to evaluate a Max message in a Binbuf, passing it arguments. ">binbuf_eval()</a> is an advanced function that evaluates the message in a Binbuf with arguments in argv, and sends it to receiver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Binbuf containing the message. </td></tr>
    <tr><td class="paramname">ac</td><td>Count of items in the argv array. </td></tr>
    <tr><td class="paramname">av</td><td>Array of t_atoms as the arguments to the message. </td></tr>
    <tr><td class="paramname">to</td><td>Receiver of the message.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of sending the message. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0eccee2d50ae561c625cc97238f1e21a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short binbuf_getatom </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt__atom.html">t_atom</a> *&#160;</td>
          <td class="paramname"><em>ap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use binbuf_getatom to retrieve a single <a class="el" href="structt__atom.html" title="An atom is a typed datum. ">t_atom</a> from a Binbuf. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Binbuf containing the desired <a class="el" href="structt__atom.html" title="An atom is a typed datum. ">t_atom</a>. </td></tr>
    <tr><td class="paramname">p1</td><td>Offset into the Binbuf's array of types. Modified to point to the next <a class="el" href="structt__atom.html" title="An atom is a typed datum. ">t_atom</a>. </td></tr>
    <tr><td class="paramname">p2</td><td>Offset into the Binbuf's array of data. Modified to point to the next <a class="el" href="structt__atom.html" title="An atom is a typed datum. ">t_atom</a>. </td></tr>
    <tr><td class="paramname">ap</td><td>Location of a <a class="el" href="structt__atom.html" title="An atom is a typed datum. ">t_atom</a> where the retrieved data will be placed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if there were no t_atoms at the specified offsets, 0 if there's a legitimate <a class="el" href="structt__atom.html" title="An atom is a typed datum. ">t_atom</a> returned in result.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>To get the first <a class="el" href="structt__atom.html" title="An atom is a typed datum. ">t_atom</a>, set both typeOffset and stuffOffset to 0. Here's an example of getting all the items in a Binbuf: <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;t_atom holder; </div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;long to, so; </div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;to = 0; </div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;so = 0; </div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;while (!binbuf_getatom(x, &amp;to, &amp;so, &amp;holder)){</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;   // do something with the t_atom</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;}</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="gad8f2272c95a8e89f22f1a9c67272af5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void binbuf_insert </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt__symbol.html">t_symbol</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt__atom.html">t_atom</a> *&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use <a class="el" href="group__binbuf.html#gad8f2272c95a8e89f22f1a9c67272af5e" title="Use binbuf_insert() to append a Max message to a Binbuf adding a semicolon. ">binbuf_insert()</a> to append a Max message to a Binbuf adding a semicolon. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Binbuf to receive the items. </td></tr>
    <tr><td class="paramname">s</td><td>Ignored. Pass NULL. </td></tr>
    <tr><td class="paramname">argc</td><td>Count of items in the argv array. </td></tr>
    <tr><td class="paramname">argv</td><td>Array of t_atoms to add to the Binbuf.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>You'll use <a class="el" href="group__binbuf.html#gad8f2272c95a8e89f22f1a9c67272af5e" title="Use binbuf_insert() to append a Max message to a Binbuf adding a semicolon. ">binbuf_insert()</a> instead of <a class="el" href="group__binbuf.html#ga57f584204ff1860c93ca728ca991fb15" title="Use binbuf_append to append t_atoms to a Binbuf without modifying them. ">binbuf_append()</a> if you were saving your object into a Binbuf and wanted a semicolon at the end. If the message is part of a file that will later be evaluated, such as a Patcher file, the first argument argv[0] will be the receiver of the message and must be a Symbol. <a class="el" href="group__binbuf.html#ga8bc71e59211549a9927754452b2d9e21" title="Use binbuf_vinsert() to append a Max message to a Binbuf adding a semicolon. ">binbuf_vinsert()</a> is easier to use than <a class="el" href="group__binbuf.html#gad8f2272c95a8e89f22f1a9c67272af5e" title="Use binbuf_insert() to append a Max message to a Binbuf adding a semicolon. ">binbuf_insert()</a>, since you don't have to format your data into an array of Atoms first.</dd></dl>
<p><a class="el" href="group__binbuf.html#gad8f2272c95a8e89f22f1a9c67272af5e" title="Use binbuf_insert() to append a Max message to a Binbuf adding a semicolon. ">binbuf_insert()</a> will also convert the t_symbols #1 through #9 into $1 through $9. This is used for saving patcher files that take arguments; you will probably never save these symbols as part of anything you are doing. </p>

</div>
</div>
<a class="anchor" id="ga4a6b741be0bee8626b4cb25baa453060"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* binbuf_new </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use <a class="el" href="group__binbuf.html#ga4a6b741be0bee8626b4cb25baa453060" title="Use binbuf_new() to create and initialize a Binbuf. ">binbuf_new()</a> to create and initialize a Binbuf. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a new binbuf if successful, otherwise NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="ga716d66a159b96b7b9d87baaab33367e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void binbuf_set </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt__symbol.html">t_symbol</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt__atom.html">t_atom</a> *&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use <a class="el" href="group__binbuf.html#ga716d66a159b96b7b9d87baaab33367e0" title="Use binbuf_set() to change the entire contents of a Binbuf. ">binbuf_set()</a> to change the entire contents of a Binbuf. </p>
<p>The previous contents of the Binbuf are destroyed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Binbuf to receive the items. </td></tr>
    <tr><td class="paramname">s</td><td>Ignored. Pass NULL. </td></tr>
    <tr><td class="paramname">argc</td><td>Count of items in the argv array. </td></tr>
    <tr><td class="paramname">argv</td><td>Array of t_atoms to put in the Binbuf. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7a582c876ee074505762b30c7eef6504"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short binbuf_text </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>srcText</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use <a class="el" href="group__binbuf.html#ga7a582c876ee074505762b30c7eef6504" title="Use binbuf_text() to convert a text handle to a Binbuf. ">binbuf_text()</a> to convert a text handle to a Binbuf. </p>
<p><a class="el" href="group__binbuf.html#ga7a582c876ee074505762b30c7eef6504" title="Use binbuf_text() to convert a text handle to a Binbuf. ">binbuf_text()</a> parses the text in the handle srcText and converts it into binary format. Use it to evaluate a text file or text line entry into a Binbuf.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Binbuf to contain the converted text. It must have already been created with binbuf_new. Its previous contents are destroyed. </td></tr>
    <tr><td class="paramname">srcText</td><td>Handle to the text to be converted. It need not be terminated with a 0. </td></tr>
    <tr><td class="paramname">n</td><td>Number of characters in the text. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If binbuf_text encounters an error during its operation, a non-zero result is returned, otherwise it returns 0.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Note: Commas, symbols containing a dollar sign followed by a number 1-9, and semicolons are identified by special pseudo-type constants for you when your text is binbuf-ized.</dd></dl>
<p>The following constants in the a_type field of Atoms returned by binbuf_getAtom identify the special symbols <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47ac105be4ef726ee36c4330e16bb24706e" title="semicolon ">A_SEMI</a>, <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47a07c3484085a3217107acec059d17b945" title="comma ">A_COMMA</a>, and <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47af0a5a9017f6b59e82a4859cd0560d36b" title="dollar ">A_DOLLAR</a>.</p>
<p>For a <a class="el" href="structt__atom.html" title="An atom is a typed datum. ">t_atom</a> of the pseudo-type <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47af0a5a9017f6b59e82a4859cd0560d36b" title="dollar ">A_DOLLAR</a>, the a_w.w_long field of the <a class="el" href="structt__atom.html" title="An atom is a typed datum. ">t_atom</a> contains the number after the dollar sign in the original text or symbol.</p>
<p>Using these pseudo-types may be helpful in separating 'sentences' and 'phrases' in the input language you design. For example, the old pop-up umenu object allowed users to have spaces in between words by requiring the menu items be separated by commas. It's reasonably easy, using <a class="el" href="group__binbuf.html#ga0eccee2d50ae561c625cc97238f1e21a" title="Use binbuf_getatom to retrieve a single t_atom from a Binbuf. ">binbuf_getatom()</a>, to find the commas in a Binbuf in order to determine the beginning of a new item when reading the atomized text to be displayed in the menu.</p>
<p>If you want to use a literal comma or semicolon in a symbol, precede it with a backslash (\) character. The backslash character can be included by using two backslashes in a row. </p>

</div>
</div>
<a class="anchor" id="gaf86f516fd1846864d5226f302857e533"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short binbuf_totext </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>dstText</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__misc.html#gabf342d55302cfc673a3b6b14e583e3cd">t_ptr_size</a> *&#160;</td>
          <td class="paramname"><em>sizep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use <a class="el" href="group__binbuf.html#gaf86f516fd1846864d5226f302857e533" title="Use binbuf_totext() to convert a Binbuf into a text handle. ">binbuf_totext()</a> to convert a Binbuf into a text handle. </p>
<p><a class="el" href="group__binbuf.html#gaf86f516fd1846864d5226f302857e533" title="Use binbuf_totext() to convert a Binbuf into a text handle. ">binbuf_totext()</a> converts a Binbuf into text and places it in a handle. Backslashes are added to protect literal commas and semicolons contained in symbols. The pseudo-types are converted into commas, semicolons, or dollar-sign and number, without backslashes preceding them. binbuf_text can read the output of binbuf_totext and make the same Binbuf.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Binbuf with data to convert to text. </td></tr>
    <tr><td class="paramname">dstText</td><td>Pre-existing handle where the text will be placed. dstText will be resized to accomodate the text. </td></tr>
    <tr><td class="paramname">sizep</td><td>Where <a class="el" href="group__binbuf.html#gaf86f516fd1846864d5226f302857e533" title="Use binbuf_totext() to convert a Binbuf into a text handle. ">binbuf_totext()</a> returns the number of characters in the converted text handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If binbuf_totext runs out of memory during its operation, it returns a non-zero result, otherwise it returns 0. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8bc71e59211549a9927754452b2d9e21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void binbuf_vinsert </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use <a class="el" href="group__binbuf.html#ga8bc71e59211549a9927754452b2d9e21" title="Use binbuf_vinsert() to append a Max message to a Binbuf adding a semicolon. ">binbuf_vinsert()</a> to append a Max message to a Binbuf adding a semicolon. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Binbuf containing the desired <a class="el" href="structt__atom.html" title="An atom is a typed datum. ">t_atom</a>. </td></tr>
    <tr><td class="paramname">fmt</td><td>A C-string containing one or more letters corresponding to the types of each element of the message. s for <a class="el" href="structt__symbol.html" title="The symbol. ">t_symbol</a>*, l for long, or f for float. </td></tr>
    <tr><td class="paramname">...</td><td>Elements of the message, passed directly to the function as Symbols, longs, or floats.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><a class="el" href="group__binbuf.html#ga8bc71e59211549a9927754452b2d9e21" title="Use binbuf_vinsert() to append a Max message to a Binbuf adding a semicolon. ">binbuf_vinsert()</a> works somewhat like a printf() for Binbufs. It allows you to pass a number of arguments of different types and insert them into a Binbuf. The entire message will then be terminated with a semicolon. Only 16 items can be passed to <a class="el" href="group__binbuf.html#ga8bc71e59211549a9927754452b2d9e21" title="Use binbuf_vinsert() to append a Max message to a Binbuf adding a semicolon. ">binbuf_vinsert()</a>.</dd></dl>
<p>The example below shows the implementation of a normal object's save method. The save method requires that you build a message that begins with #N (the new object) , followed by the name of your object (in this case, represented by the <a class="el" href="structt__symbol.html" title="The symbol. ">t_symbol</a> myobject), followed by any arguments your instance creation function requires. In this example, we save the values of two fields m_val1 and m_val2 defined as longs.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;void myobject_save (myObject *x, Binbuf *dstBuf) </div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;{ </div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;   binbuf_vinsert(dstBuf, &quot;ssll&quot;, gensym(&quot;#N&quot;), </div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;       gensym(&quot;myobject&quot;), </div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;       x-&gt;m_val1, x-&gt;m_val2); </div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;}</div>
</div><!-- fragment --><p>Suppose that such an object had written this data into a file. If you opened the file as text, you would see the following:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;#N myobject 10 20; </div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;#P newobj 218 82 30 myobject; </div>
</div><!-- fragment --><p>The first line will result in a new myobject object to be created; the creation function receives the arguments 10 and 20. The second line contains the text of the object box. The newobj message to a patcher creates the object box user interface object and attaches it to the previously created myobject object. Normally, the newex message is used. This causes the object to be created using the arguments that were typed into the object box. </p>

</div>
</div>
<a class="anchor" id="gacb42118a4da090a6d47954f8b299de46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short readatom </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>outstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt__atom.html">t_atom</a> *&#160;</td>
          <td class="paramname"><em>ap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use <a class="el" href="group__binbuf.html#gacb42118a4da090a6d47954f8b299de46" title="Use readatom() to read a single t_atom from a text buffer. ">readatom()</a> to read a single <a class="el" href="structt__atom.html" title="An atom is a typed datum. ">t_atom</a> from a text buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outstr</td><td>C-string of 256 characters that will receive the next text item read from the buffer. </td></tr>
    <tr><td class="paramname">text</td><td>Handle to the text buffer to be read. </td></tr>
    <tr><td class="paramname">n</td><td>Starts at 0, and is modified by readatom to point to the next item in the text buffer. </td></tr>
    <tr><td class="paramname">e</td><td>Number of characters in text. </td></tr>
    <tr><td class="paramname">ap</td><td>Where the resulting <a class="el" href="structt__atom.html" title="An atom is a typed datum. ">t_atom</a> read from the text buffer is placed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__binbuf.html#gacb42118a4da090a6d47954f8b299de46" title="Use readatom() to read a single t_atom from a text buffer. ">readatom()</a> returns non-zero if there is more text to read, and zero if it has reached the end of the text. Note that this return value has the opposite logic from that of <a class="el" href="group__binbuf.html#ga0eccee2d50ae561c625cc97238f1e21a" title="Use binbuf_getatom to retrieve a single t_atom from a Binbuf. ">binbuf_getatom()</a>.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function provides access to the low-level Max text evaluator used by <a class="el" href="group__binbuf.html#ga7a582c876ee074505762b30c7eef6504" title="Use binbuf_text() to convert a text handle to a Binbuf. ">binbuf_text()</a>. It is designed to operate on a handle of characters (text) and called in a loop, as in the example shown below. <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;long index = 0; </div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;t_atom dst; </div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;char outstr[256]; </div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;while (readatom(outstr,textHandle,&amp;index,textLength,&amp;dst)) </div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;{ </div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;   // do something with the resulting t_atom</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;} </div>
</div><!-- fragment --></dd>
<dd>
An alternative to using readatom is to turn your text into a Binbuf using <a class="el" href="group__binbuf.html#ga7a582c876ee074505762b30c7eef6504" title="Use binbuf_text() to convert a text handle to a Binbuf. ">binbuf_text()</a>, then call <a class="el" href="group__binbuf.html#ga0eccee2d50ae561c625cc97238f1e21a" title="Use binbuf_getatom to retrieve a single t_atom from a Binbuf. ">binbuf_getatom()</a> in a loop. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
		<div id="c74footer">
			&nbsp;&nbsp;Copyright &copy; 2013, <a href="http://www.cycling74.com/">Cycling '74</a>
		</div>
	</body>
</html>
