<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Max 6 API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
</head>
<body>
<div id="top"><!-- do not remove this div! -->
<div id="titlearea">
	<div id="c74header">
		<img src="header.png" height="100" />
	</div>
</div>
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('chapter_jit_objectmodel.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Jitter Object Model </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="chapter_jit_objectmodel_basics"></a>
Jitter Object Model Basics</h1>
<p>Jitter objects use an object model which is somewhat different than the one traditionally used for developing Max external objects. The first big difference between Jitter objects and traditional Max external objects is that Jitter objects don't have any notion of the patcher themselves. This allows for the flexible instantiation and use of Jitter objects from C, Java, JavaScript, as well as in the Max patcher. The use of these Jitter objects is exposed to the patcher with a Max "wrapper" object, which will be discussed in the following chapter.</p>
<p>In this chapter we'll restrict our discussion to the fundamentals of defining the Jitter object which can be used in any of these languages. While Jitter's primary focus is matrix processing and real-time graphics, these tasks are unrelated to the object model, and will be covered in later chapters on developing Matrix Operator (MOP) and OB3D objects. Like Max objects, Jitter objects are typically written in C. While C++ can be used to develop Jitter objects, none of the object oriented language features will be used to define your object as far as Jitter is concerned. Similar to C++ or Java objects, Jitter objects are defined by a class with methods and member variables - we will refer to the member variables as "attributes". Unlike C++ or Java, there are no language facilities that manage class definition, class inheritance, or making use of class instances. In Jitter this must all be managed with sets of standard C function calls that will define your class, exercise methods, and get and set object attributes.</p>
<p>Max and Jitter implement their object models by maintaining a registry of ordinary C functions and struct members that map to methods and attributes associated with names. When some other code wishes to make use of these methods or attributes, it asks the Jitter object to look up the method or attribute in its registry based on a name. This is called dynamic binding, and is similar to Smalltalk or Objective C's object model. C++ and Java typically make use of static binding â€” i.e. methods and member variables are resolved at compile time rather than being dynamically looked up at run time.</p>
<h1><a class="anchor" id="chapter_jit_objectmodel_classdef"></a>
Defining a Jitter Class</h1>
<p>A Jitter class is typically defined in a C function named something like your_object_name_init(). Class definition begins with a call to <a class="el" href="group__classmod.html#ga39c943d33b9aefa8deb83daa93bec1d1" title="Creates a new class with the name specified by the name argument. ">jit_class_new()</a>, which creates a new class associated with a specified name, constructor, destructor, and size in bytes of the object as stored in a C structure. This is followed by calls to <a class="el" href="group__classmod.html#ga3d3fb6b5f0696ac552b1b810a1656a73" title="Adds a named method to a class. ">jit_class_addmethod()</a> and <a class="el" href="group__classmod.html#ga37e39db544b4d73596da1557e6c7563a" title="Adds an attribute to a class. ">jit_class_addattr()</a>, which register methods and attributes with their corresponding names in the class. The class is finally registered with a call to <a class="el" href="group__classmod.html#ga1cf03eba09d7b3b53a8cde269c47765d" title="Registers class in the class registry. ">jit_class_register()</a>. A minimal example class definition is shown below:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>_jit_foo</div>
<div class="line">{</div>
<div class="line">   <a class="code" href="structt__object.html">t_jit_object</a>    ob;</div>
<div class="line">   <span class="keywordtype">float</span>          myval;</div>
<div class="line">} t_jit_foo;</div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> <a class="code" href="structt__class.html">t_jit_class</a> *_jit_foo_class=NULL;</div>
<div class="line"></div>
<div class="line">t_jit_err jit_foo_init(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">   <span class="keywordtype">long</span> attrflags=0;</div>
<div class="line">   <a class="code" href="structt__object.html">t_jit_object</a> *attr;</div>
<div class="line"></div>
<div class="line">   <span class="comment">// create new class named &quot;jit_foo&quot; with constructor + destructor</span></div>
<div class="line">   _jit_foo_class = <a class="code" href="group__classmod.html#ga39c943d33b9aefa8deb83daa93bec1d1">jit_class_new</a>(<span class="stringliteral">&quot;jit_foo&quot;</span>,(<a class="code" href="group__datatypes.html#ga4b2c39d5bd0b08acd10bffed77f0e513">method</a>)jit_foo_new,</div>
<div class="line">      (<a class="code" href="group__datatypes.html#ga4b2c39d5bd0b08acd10bffed77f0e513">method</a>)jit_foo_free, <span class="keyword">sizeof</span>(t_jit_foo), 0L);</div>
<div class="line"></div>
<div class="line">   <span class="comment">// add method to class</span></div>
<div class="line">   <a class="code" href="group__classmod.html#ga3d3fb6b5f0696ac552b1b810a1656a73">jit_class_addmethod</a>(jit_foo_scream, <span class="stringliteral">&quot;scream&quot;</span>, <a class="code" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47a7bd979db3dcf86909e24a1d1452e2205">A_DEFLONG</a>, 0L);</div>
<div class="line"></div>
<div class="line">   <span class="comment">// define attribute</span></div>
<div class="line">   attr = jit_object_new(      <span class="comment">// instantiate an object</span></div>
<div class="line">      <a class="code" href="group__jitter.html#gab40fefe3a9e395a661cdc293c1df494a">_jit_sym_jit_attr_offset</a>,   <span class="comment">// of class jit_attr_offset</span></div>
<div class="line">      <span class="stringliteral">&quot;myval&quot;</span>,         <span class="comment">// with name &quot;myval&quot;</span></div>
<div class="line">      <a class="code" href="group__jitter.html#gad7a58126ec86034d67886cf5f84f571a">_jit_sym_float32</a>,       <span class="comment">// type float32</span></div>
<div class="line">      attrflags,         <span class="comment">// default flags</span></div>
<div class="line">      (<a class="code" href="group__datatypes.html#ga4b2c39d5bd0b08acd10bffed77f0e513">method</a>)0L,         <span class="comment">// default getter accessor</span></div>
<div class="line">      (<a class="code" href="group__datatypes.html#ga4b2c39d5bd0b08acd10bffed77f0e513">method</a>)0L,         <span class="comment">// default setter accessor</span></div>
<div class="line">      <a class="code" href="group__misc.html#gaad95899dfbc7b5b8fe11921643ef46f0">calcoffset</a>(t_jit_foo,myval)); <span class="comment">// byte offset to struct member</span></div>
<div class="line"></div>
<div class="line">   <span class="comment">// add attribute object to class</span></div>
<div class="line">   <a class="code" href="group__classmod.html#ga37e39db544b4d73596da1557e6c7563a">jit_class_addattr</a>(_jit_foo_class, attr);</div>
<div class="line"></div>
<div class="line">   <span class="comment">// register class</span></div>
<div class="line">   <a class="code" href="group__classmod.html#ga1cf03eba09d7b3b53a8cde269c47765d">jit_class_register</a>(_jit_foo_class);</div>
<div class="line"></div>
<div class="line">   <span class="keywordflow">return</span> JIT_ERR_NONE;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// constructor</span></div>
<div class="line">t_jit_foo *jit_foo_new(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">   t_jit_foo *x;</div>
<div class="line"></div>
<div class="line">   <span class="comment">// allocate object</span></div>
<div class="line">   <span class="keywordflow">if</span> (x=jit_object_alloc(_jit_foo_class))</div>
<div class="line">   {</div>
<div class="line">      <span class="comment">// if successful, perform any initialization</span></div>
<div class="line">      x-&gt;myval = 0;</div>
<div class="line">   }</div>
<div class="line">   <span class="keywordflow">return</span> x;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// destructor</span></div>
<div class="line"><span class="keywordtype">void</span> jit_foo_free(t_jit_foo *x)</div>
<div class="line">{</div>
<div class="line">   <span class="comment">// would free any necessary resources here</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// scream method</span></div>
<div class="line"><span class="keywordtype">void</span> jit_foo_scream(t_jit_foo *x, <span class="keywordtype">long</span> i)</div>
<div class="line">{</div>
<div class="line">   <a class="code" href="group__console.html#ga8eebb1400d598f4423f925102d02970a">post</a>(<span class="stringliteral">&quot;MY VALUE IS %f! AND MY ARGUMENT IS %d&quot;</span>, x-&gt;myval, i);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The above example has a constructor, jit_foo_new(); a destructor, jit_foo_free(); one 32 bit floating point attribute, myval, a member of the object struct accessed with default accessor methods; and a method jit_foo_scream(), which posts the current value of myval to the Max window.</p>
<h1><a class="anchor" id="chapter_jit_objectmodel_struct"></a>
Object Struct</h1>
<p>Each instance of an object occupies some region of organized memory. The C structure that defines this organization of memory is typically referred to as the "object struct". It is important that the object struct always begin with an entry of type <a class="el" href="group__jitter.html#ga0eb2cd9c8e3b9803ba31069575a1ffb9" title="object header ">t_jit_object</a>. It is within the <a class="el" href="group__jitter.html#ga0eb2cd9c8e3b9803ba31069575a1ffb9" title="object header ">t_jit_object</a> where special information about the class is kept. The C structure can contain additional information, either exposed as attributes or not, but it is important that the size of the object struct does not exceed 16384 bytes. This means that it is not safe to define a large array as a struct entry if it will cause the size of the object struct to be larger than this limit. If additional memory is required, the object struct should contain a pointer to memory allocated from within the constructor, and freed within the destructor.</p>
<p>The class registration in the above code makes use of the object struct both to record in the class how large each object instance should beâ€”i.e. sizeof(t_jit_foo) ; and at what byte offset in the object struct an attribute is locatedâ€”i.e. <a class="el" href="group__misc.html#gaad95899dfbc7b5b8fe11921643ef46f0" title="Find byte offset of a named member of a struct, relative to the beginning of that struct...">calcoffset(t_jit_foo, myval)</a> . When methods of an object are called, the instance of the object struct is passed as the first argument to the C functions which define the object methods. This instance may be thought of as similar to the "this" keyword used in C++ and Java - actually the C++ and Java underlying implementation works quite similarly to what has been implemented here in pure C. Object struct entries may be thought of as similar to object member variables, but methods must be called via functions rather than simply dereferencing instances of the class as you might do in C++ or Java. The list of object methods and other class information is referenced by your object's <a class="el" href="group__jitter.html#ga0eb2cd9c8e3b9803ba31069575a1ffb9" title="object header ">t_jit_object</a> entry.</p>
<h1><a class="anchor" id="chapter_jit_objectmodel_ctordtor"></a>
Constructor/Destructor</h1>
<p>The two most important methods that are required for all objects are the constructor and the destructor. These are typically named your_object_name_new(), and your_object_name_free(), respectively. It is the constructor's responsibility to allocate and initialize the object struct and any additional resources the object instance requires. The object struct is allocated via jit_object_alloc(), which also initializes the <a class="el" href="group__jitter.html#ga0eb2cd9c8e3b9803ba31069575a1ffb9" title="object header ">t_jit_object</a> struct entry to point at your relevant class information. The class information resides in your global class variable, e.g. _jit_foo_class, which you pass as an argument to jit_object_alloc(). This allocation does not, however initialize the other struct entries, such as "myval", which you must explicitly initialize if your allocation is successful. Note that because the constructor allocates the object instance, no object instance is passed as the first argument to the function which defines the constructor, unlike other object methods.</p>
<p>The constructor also has the option of having a typed argument signature with the same types as defined in the Writing Max Externals documentationâ€”i.e. <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47a002f28879581a6f66ea492b994b96f1e" title="long integer ">A_LONG</a>, <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47a0b3aa0ab8104573dfc9cb70b5b08031f" title="32-bit float ">A_FLOAT</a>, <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47a2d661c2a5d949566e2f1944c99bceeea" title="t_symbol pointer ">A_SYM</a>, <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47a81c1a8550f038db16a619167a70a79b6" title="request that args be passed as an array, the routine will check the types itself. ...">A_GIMME</a>, etc. Typically, Jitter object constructors either have no arguments or use the <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47a81c1a8550f038db16a619167a70a79b6" title="request that args be passed as an array, the routine will check the types itself. ...">A_GIMME</a> typed argument signature.</p>
<p>In earlier versions of Jitter, the constructors were often specified as private and "untyped" using the <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47af48193ec36e53b1507d81c49873c8d7a" title="cannot typecheck args ">A_CANT</a> type signature. While this obsolete style of an untyped constructor will work for the exposure of a Jitter class to the patcher and C, it is now discouraged, as there must be a valid type signature for exposure of a class to Javascript or Java, though that signature may be the empty list.</p>
<p>It is the destructor's responsibility to free any resources allocated, with the exception of the object struct itself. The object struct is freed for you after your destructor exits.</p>
<h1><a class="anchor" id="chapter_jit_objectmodel_methods"></a>
Methods</h1>
<p>You can define additional methods using the <a class="el" href="group__classmod.html#ga3d3fb6b5f0696ac552b1b810a1656a73" title="Adds a named method to a class. ">jit_class_addmethod()</a> function. This example defines the scream method associated with the function jit_foo_scream(), with no additional arguments aside from the standard first argument of a pointer to the object struct. Just like methods for ordinary Max objects, these methods could have a typed argument signature with the same types as defined in the Writing Max Externals documentation â€” i.e. <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47a002f28879581a6f66ea492b994b96f1e" title="long integer ">A_LONG</a>, <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47a0b3aa0ab8104573dfc9cb70b5b08031f" title="32-bit float ">A_FLOAT</a>, <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47a2d661c2a5d949566e2f1944c99bceeea" title="t_symbol pointer ">A_SYM</a>, <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47a81c1a8550f038db16a619167a70a79b6" title="request that args be passed as an array, the routine will check the types itself. ...">A_GIMME</a>. Typically in Jitter objects, public methods are specified either without arguments, or use <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47a81c1a8550f038db16a619167a70a79b6" title="request that args be passed as an array, the routine will check the types itself. ...">A_GIMME</a>, or the low priority variants, <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47a4556bc5fe0d4f8cc55eda5aeeee55cf2" title="A special signature for declaring methods. This is like A_GIMME, but the call is deferref to the back...">A_DEFER_LOW</a>, or <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47a8c844b0a1b551341a6a5e3b95d2f1152" title="A special signature for declaring methods. This is like A_GIMME, but the call is deferred to the back...">A_USURP_LOW</a>, which will be discussed in following chapters. Private methods, just like their Max equivalent should be defined as untyped, using the <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47af48193ec36e53b1507d81c49873c8d7a" title="cannot typecheck args ">A_CANT</a> type signature. Object methods can be called from C either by calling the C function directly, or by using jit_object_method() or <a class="el" href="group__objectmod.html#ga9c9b8591a887cddd19b313c8e995fbea" title="Calls a typed object method specified by method name. ">jit_object_method_typed()</a>. For example, the following calls that relate to the above jit_foo example are equivalent:</p>
<div class="fragment"><div class="line"><span class="comment">// call scream method directly</span></div>
<div class="line">jit_foo_scream(x, 74);</div>
<div class="line"></div>
<div class="line"><span class="comment">// dynamically resolve and call scream method</span></div>
<div class="line">jit_object_method(x, <a class="code" href="group__symbol.html#ga5d8db08b384aeb76eaee85a15f46fbcb">gensym</a>(<span class="stringliteral">&quot;scream&quot;</span>), 74);</div>
<div class="line"></div>
<div class="line"><span class="comment">// dynamically resolve and call scream method with typed atom arguments</span></div>
<div class="line"><a class="code" href="structt__atom.html">t_atom</a> a[1];</div>
<div class="line"><a class="code" href="group__atommod.html#ga0ad1eac4cdeb76a48a3056d83759276b">jit_atom_setlong</a>(a, 74);</div>
<div class="line"><a class="code" href="group__objectmod.html#ga9c9b8591a887cddd19b313c8e995fbea">jit_object_method_typed</a>(x, <a class="code" href="group__symbol.html#ga5d8db08b384aeb76eaee85a15f46fbcb">gensym</a>(<span class="stringliteral">&quot;scream&quot;</span>), 1, a, NULL);</div>
</div><!-- fragment --><p>What the jit_object_method() and <a class="el" href="group__objectmod.html#ga9c9b8591a887cddd19b313c8e995fbea" title="Calls a typed object method specified by method name. ">jit_object_method_typed()</a> functions do is look up the provided method symbol in the object's class information, and then calls the corresponding C function associated with the provided symbol. The difference between jit_object_method() and <a class="el" href="group__objectmod.html#ga9c9b8591a887cddd19b313c8e995fbea" title="Calls a typed object method specified by method name. ">jit_object_method_typed()</a> is that jit_object_method() will not require that the method is typed and public, and blindly pass all of the arguments following the method symbol on to the corresponding method. For this reason, it is required that you know the signature of the method you are calling, and pass the correct arguments. This is not type checked at compile time, so you must be extremely attentive to the arguments you pass via jit_object_method(). It is also possible for you to define methods which have a typed return value with the <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47ad150bf3de9c8dc2ddfa0ca0ca2382360" title="request that args be passed as an array, the routine will check the types itself. can return atom val...">A_GIMMEBACK</a> type signature. When calling such methods, the final argument to <a class="el" href="group__objectmod.html#ga9c9b8591a887cddd19b313c8e995fbea" title="Calls a typed object method specified by method name. ">jit_object_method_typed()</a>, should point to a <a class="el" href="structt__atom.html" title="An atom is a typed datum. ">t_atom</a> to be filled in by the callee. This and the subject of "typed wrappers" for exposing otherwise private methods to language bindings that require typed methods (e.g. Java/!JavaScript) will be covered in a later chapter.</p>
<h1><a class="anchor" id="chapter_jit_objectmodel_attrs"></a>
Attributes</h1>
<p>You can add attributes to the class with <a class="el" href="group__classmod.html#ga37e39db544b4d73596da1557e6c7563a" title="Adds an attribute to a class. ">jit_class_addattr()</a>. Attributes themselves are Jitter objects which share a common interface for getting and setting values. While any class which conforms to the attribute interface could be used to define attributes of a given class, there are a few common classes which are currently used: jit_attr_offset(), which specifies a scalar attribute of a specific type (char, long, float32, float64, symbol, or atom) at some byte offset in the object struct; jit_attr_offset_array() which specifies an array (vector) attribute of a specific type (char, long, float32, float64, symbol, or atom) at some byte offset in the object struct; and jit_attribute, which is a more generic attribute object that can be instantiated on a per object basis. We will not document the usage of jit_attribute at this time. The constructor for the class jit_attr_offset() has the following prototype:</p>
<div class="fragment"><div class="line"><a class="code" href="structt__object.html">t_jit_object</a> *<a class="code" href="group__attrmod.html#gaf1539159e0a0bb0238b2cf9b03ac3308">jit_attr_offset_new</a>(<span class="keywordtype">char</span> *name, <a class="code" href="structt__symbol.html">t_symbol</a> *type, <span class="keywordtype">long</span> flags,</div>
<div class="line">   <a class="code" href="group__datatypes.html#ga4b2c39d5bd0b08acd10bffed77f0e513">method</a> mget, <a class="code" href="group__datatypes.html#ga4b2c39d5bd0b08acd10bffed77f0e513">method</a> mset, <span class="keywordtype">long</span> offset);</div>
</div><!-- fragment --><p>When this constructor is called via jit_object_new(), additionally the class name, <a class="el" href="group__jitter.html#gab40fefe3a9e395a661cdc293c1df494a" title="cached t_symbol ">_jit_sym_jit_attr_offset</a> (a global variable equivalent to gensym("jit_attr_offset") ) must be passed as the first parameter, followed by the above arguments, which are passed on to the constructor. The name argument specifies the attribute name as a null terminated C string. The type argument specifies the attribute type, which may be one of the following symbols: <a class="el" href="group__jitter.html#ga3a06cf8d41c4f4c017c0bf825fec59f8" title="cached t_symbol ">_jit_sym_char</a>, <a class="el" href="group__jitter.html#gae0e378fee570c930c7000241ed01f90d" title="cached t_symbol ">_jit_sym_long</a>, <a class="el" href="group__jitter.html#gad7a58126ec86034d67886cf5f84f571a" title="cached t_symbol ">_jit_sym_float32</a>, <a class="el" href="group__jitter.html#gaa70b05cff70f1551500b1523158402fa" title="cached t_symbol ">_jit_sym_float64</a>, <a class="el" href="group__jitter.html#ga1fbdf150f10bf608a6f3a6d872e25a54" title="cached t_symbol ">_jit_sym_symbol</a>, <a class="el" href="group__jitter.html#gaa373c8f1a669e3d53925fcb2ac6c5e0c" title="cached t_symbol ">_jit_sym_atom</a>, <a class="el" href="group__jitter.html#gae0b79c9729865252601181207a5affdb" title="cached t_symbol ">_jit_sym_object</a>, or <a class="el" href="group__jitter.html#ga54ba6c52fd6d460bee49cee4e39940f4" title="cached t_symbol ">_jit_sym_pointer</a>. The latter two are only useful for private attributes as these types are not exposed to, or converted from Max message atom values.</p>
<p>The flags argument specifies the attribute flags, which may be a bitwise combination of the following constants:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define JIT_ATTR_GET_OPAQUE           0x00000001 // cannot query</span></div>
<div class="line"><span class="preprocessor">#define JIT_ATTR_SET_OPAQUE           0x00000002 // cannot set</span></div>
<div class="line"><span class="preprocessor">#define JIT_ATTR_GET_OPAQUE_USER      0x00000100 // user cannot query</span></div>
<div class="line"><span class="preprocessor">#define JIT_ATTR_SET_OPAQUE_USER      0x00000200 // user cannot set</span></div>
<div class="line"><span class="preprocessor">#define JIT_ATTR_GET_DEFER            0x00010000 // (deprecated)</span></div>
<div class="line"><span class="preprocessor">#define JIT_ATTR_GET_USURP            0x00020000 // (deprecated)</span></div>
<div class="line"><span class="preprocessor">#define JIT_ATTR_GET_DEFER_LOW        0x00040000 // query in low priority</span></div>
<div class="line"><span class="preprocessor">#define JIT_ATTR_GET_USURP_LOW        0x00080000 // query in low, usurping</span></div>
<div class="line"><span class="preprocessor">#define JIT_ATTR_SET_DEFER            0x01000000 // (deprecated)</span></div>
<div class="line"><span class="preprocessor">#define JIT_ATTR_SET_USURP            0x02000000 // (deprecated)</span></div>
<div class="line"><span class="preprocessor">#define JIT_ATTR_SET_DEFER_LOW        0x04000000 // set at low priority</span></div>
<div class="line"><span class="preprocessor">#define JIT_ATTR_SET_USURP_LOW        0x08000000 // set at low, usurping</span></div>
</div><!-- fragment --><p>Typically attributes in Jitter are defined with flags <a class="el" href="group__jitter.html#ga810447020b75b5173d4c6776cd2653d8" title="defer getter ">JIT_ATTR_GET_DEFER_LOW</a>, and <a class="el" href="group__jitter.html#ga2ffda4034665d46f65461d67b1004715" title="usurp setter ">JIT_ATTR_SET_USURP_LOW</a>. This means that multiple queries from the patcher will generate a response for each query, and that multiple attempts to set the value at high priority will collapse into a single call with the last received value. For more information on defer and usurp, see the chapter on Jitter scheduling issues.</p>
<p>The mget argument specifies the attribute "getter" accessor method, used to query the attribute value. If this argument is zero (NULL), then the default getter accessor will be used. If you need to define a custom accessor, it should have a prototype and form comparable to the following custom getter:</p>
<div class="fragment"><div class="line">t_jit_err jit_foo_myval_get(t_jit_foo *x, <span class="keywordtype">void</span> *attr, <span class="keywordtype">long</span> *ac, <a class="code" href="structt__atom.html">t_atom</a> **av)</div>
<div class="line">{</div>
<div class="line">   <span class="keywordflow">if</span> ((*ac)&amp;&amp;(*av)) {</div>
<div class="line">      <span class="comment">//memory passed in, use it</span></div>
<div class="line">   } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="comment">//otherwise allocate memory</span></div>
<div class="line">      *ac = 1;</div>
<div class="line">      <span class="keywordflow">if</span> (!(*av = <a class="code" href="group__memorymod.html#ga348f78687a0aabb79d772d633cc679cc">jit_getbytes</a>(<span class="keyword">sizeof</span>(<a class="code" href="structt__atom.html">t_atom</a>)*(*ac)))) {</div>
<div class="line">         *ac = 0;</div>
<div class="line">         <span class="keywordflow">return</span> JIT_ERR_OUT_OF_MEM;</div>
<div class="line">      }</div>
<div class="line">   }</div>
<div class="line">   <a class="code" href="group__atommod.html#gafa6fc51c30c70d54d6dd4af45042d3bd">jit_atom_setfloat</a>(*av,x-&gt;myval);</div>
<div class="line"></div>
<div class="line">   <span class="keywordflow">return</span> JIT_ERR_NONE;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that getters require memory to be allocated, if there is not memory passed into the getter. Also the attr argument is the class' attribute object and can be queried using jit_object_method() for things like the attribute flags, names, filters, etc.. The mset argument specifies the attribute "setter" accessor method, used to set the attribute value. If this argument is zero (NULL), then the default setter accessor will be used. If we need to define a custom accessor, it should have a prototype and form comparable to the following custom setter:</p>
<div class="fragment"><div class="line">t_jit_err jit_foo_myval_set(t_jit_foo *x, <span class="keywordtype">void</span> *attr, <span class="keywordtype">long</span> ac, <a class="code" href="structt__atom.html">t_atom</a> *av)</div>
<div class="line">{</div>
<div class="line">   <span class="keywordflow">if</span> (ac&amp;&amp;av) {</div>
<div class="line">      x-&gt;myval = <a class="code" href="group__atommod.html#gae5882d0bf97c939882126ba235eee409">jit_atom_getfloat</a>(av);</div>
<div class="line">   } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="comment">// no args, set to zero</span></div>
<div class="line">      x-&gt;myval = 0;</div>
<div class="line">   }</div>
<div class="line">   <span class="keywordflow">return</span> JIT_ERR_NONE;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The offset argument specifies the attribute's byte offset in the object struct, used by default getters and setters to automatically query and set the attribute's value. If you have both custom accessors, this value is ignored. This can be a useful strategy to employ if you wish to have an object attribute that does not correspond to any actual entry in your object struct. For example, this is how we implement the time attribute of jit.movie â€” i.e. it uses a custom getter and setter which make QuickTime API calls to query and set the current movie time, rather than manipulating the object struct itself, where no information about movie time is actually stored. In such an instance, you should set this offset to zero.</p>
<p>After creating the attribute, it must be added to the Jitter class using the <a class="el" href="group__classmod.html#ga37e39db544b4d73596da1557e6c7563a" title="Adds an attribute to a class. ">jit_class_addattr()</a> function:</p>
<div class="fragment"><div class="line">t_jit_err <a class="code" href="group__classmod.html#ga37e39db544b4d73596da1557e6c7563a">jit_class_addattr</a>(<span class="keywordtype">void</span> *c, <a class="code" href="structt__object.html">t_jit_object</a> *attr);</div>
</div><!-- fragment --><p>To put it all together: to define a jit_attribute_offset() with the custom getter and setter functions defined above, you'd make the following call:</p>
<div class="fragment"><div class="line"><span class="keywordtype">long</span> attrflags = <a class="code" href="group__jitter.html#ga810447020b75b5173d4c6776cd2653d8">JIT_ATTR_GET_DEFER_LOW</a> | <a class="code" href="group__jitter.html#ga2ffda4034665d46f65461d67b1004715">JIT_ATTR_SET_USURP_LOW</a>;</div>
<div class="line"><a class="code" href="structt__object.html">t_jit_object</a> *attr = jit_object_new(<a class="code" href="group__jitter.html#gab40fefe3a9e395a661cdc293c1df494a">_jit_sym_jit_attr_offset</a>, <span class="stringliteral">&quot;myval&quot;</span>, <a class="code" href="group__jitter.html#gad7a58126ec86034d67886cf5f84f571a">_jit_sym_float32</a>, attrflags,</div>
<div class="line">   (<a class="code" href="group__datatypes.html#ga4b2c39d5bd0b08acd10bffed77f0e513">method</a>)jit_foo_myval_get, (<a class="code" href="group__datatypes.html#ga4b2c39d5bd0b08acd10bffed77f0e513">method</a>)jit_foo_myval_set, NULL);</div>
<div class="line"><a class="code" href="group__classmod.html#ga37e39db544b4d73596da1557e6c7563a">jit_class_addattr</a>(_jit_foo_class, attr);</div>
</div><!-- fragment --><p>And to define a completely standard jit_attribute_offset(), using the default getter and setter methods:</p>
<div class="fragment"><div class="line"><span class="keywordtype">long</span> attrflags = <a class="code" href="group__jitter.html#ga810447020b75b5173d4c6776cd2653d8">JIT_ATTR_GET_DEFER_LOW</a> | <a class="code" href="group__jitter.html#ga2ffda4034665d46f65461d67b1004715">JIT_ATTR_SET_USURP_LOW</a>;</div>
<div class="line"><a class="code" href="structt__object.html">t_jit_object</a> *attr = jit_object_new(<a class="code" href="group__jitter.html#gab40fefe3a9e395a661cdc293c1df494a">_jit_sym_jit_attr_offset</a>, <span class="stringliteral">&quot;myval&quot;</span>, <a class="code" href="group__jitter.html#gad7a58126ec86034d67886cf5f84f571a">_jit_sym_float32</a>, attrflags,</div>
<div class="line">   (<a class="code" href="group__datatypes.html#ga4b2c39d5bd0b08acd10bffed77f0e513">method</a>)NULL, (<a class="code" href="group__datatypes.html#ga4b2c39d5bd0b08acd10bffed77f0e513">method</a>)NULL, <a class="code" href="group__misc.html#gaad95899dfbc7b5b8fe11921643ef46f0">calcoffset</a>(t_jit_foo, myval));</div>
<div class="line"><a class="code" href="group__classmod.html#ga37e39db544b4d73596da1557e6c7563a">jit_class_addattr</a>(_jit_foo_class, attr);</div>
</div><!-- fragment --><h1><a class="anchor" id="chapter_jit_objectmodel_arrayattrs"></a>
Array Attributes</h1>
<p>Attributes can, in addition to referencing single values, also refer to arrays of data. The class jit_attribute_offset_array is used in this instance. The constructor for the class jit_attr_offset_array() has the following prototype:</p>
<div class="fragment"><div class="line"><a class="code" href="structt__object.html">t_jit_object</a> *<a class="code" href="group__attrmod.html#ga8da2f33df7efd0c23b0b7a68ec402724">jit_attr_offset_array_new</a>(<span class="keywordtype">char</span> *name, <a class="code" href="structt__symbol.html">t_symbol</a> *type, <span class="keywordtype">long</span> size,</div>
<div class="line">   <span class="keywordtype">long</span> flags, <a class="code" href="group__datatypes.html#ga4b2c39d5bd0b08acd10bffed77f0e513">method</a> mget, <a class="code" href="group__datatypes.html#ga4b2c39d5bd0b08acd10bffed77f0e513">method</a> mset, <span class="keywordtype">long</span> offsetcount, <span class="keywordtype">long</span> offset);</div>
</div><!-- fragment --><p>When this constructor is called via jit_object_new(), additionally the class name, <a class="el" href="group__jitter.html#ga8d45907c4b422b4bc86deaf84adf1ad8" title="cached t_symbol ">_jit_sym_jit_attr_offset_array()</a> (a global variable equivalent to gensym("jit_attr_offset_array") ) must be passed as the first parameter, followed by the above arguments, which are passed on to the constructor.</p>
<p>The name, type, flags, mget, mset and offset arguments are identical to those specified above.</p>
<p>The size argument specifies the maximum length of the array (the allocated size of the array in the Jitter object struct). The offsetcount specifies the byte offset in the object struct, where the actual length of the array can be queried/set. This value should be specified as a long. This value is used by default getters and setters when querying and setting the attribute's value. As with the jit_attr_offset object, if you have both custom accessors, this value is ignored.</p>
<p>The following sample listing demonstrates the creation of a simple instance of the jit_attr_offset_array() class for an object defined as:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>_jit_foo</div>
<div class="line">{</div>
<div class="line">   <a class="code" href="structt__object.html">t_jit_object</a>     ob;</div>
<div class="line">   <span class="keywordtype">long</span>             myarray[10]; <span class="comment">// max of 10 entries in this array</span></div>
<div class="line">   <span class="keywordtype">long</span>             myarraycount; <span class="comment">// actual number being used</span></div>
<div class="line">} t_jit_foo;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">long</span> attrflags = <a class="code" href="group__jitter.html#ga810447020b75b5173d4c6776cd2653d8">JIT_ATTR_GET_DEFER_LOW</a> | <a class="code" href="group__jitter.html#ga2ffda4034665d46f65461d67b1004715">JIT_ATTR_SET_USURP_LOW</a>;</div>
<div class="line"><a class="code" href="structt__object.html">t_jit_object</a> *attr = jit_object_new(<a class="code" href="group__jitter.html#ga8d45907c4b422b4bc86deaf84adf1ad8">_jit_sym_jit_attr_offset_array</a>, <span class="stringliteral">&quot;myarray&quot;</span>,</div>
<div class="line">   <a class="code" href="group__jitter.html#gae0e378fee570c930c7000241ed01f90d">_jit_sym_long</a>, 10, attrflags, (<a class="code" href="group__datatypes.html#ga4b2c39d5bd0b08acd10bffed77f0e513">method</a>)0L, (<a class="code" href="group__datatypes.html#ga4b2c39d5bd0b08acd10bffed77f0e513">method</a>)0L,</div>
<div class="line">   <a class="code" href="group__misc.html#gaad95899dfbc7b5b8fe11921643ef46f0">calcoffset</a>(t_jit_foo, myarraycount), <a class="code" href="group__misc.html#gaad95899dfbc7b5b8fe11921643ef46f0">calcoffset</a>(t_jit_foo, myarray));</div>
<div class="line"><a class="code" href="group__classmod.html#ga37e39db544b4d73596da1557e6c7563a">jit_class_addattr</a>(_jit_foo_class, attr);</div>
</div><!-- fragment --><h1><a class="anchor" id="chapter_jit_objectmodel_attrnotifications"></a>
Attribute Notification</h1>
<p>Although the subject of object registration and notification will be covered in greater depth in a forthcoming chapter, it bears noting that attributes of all types (e.g. jit_attr_offset, jit_attr_offset_array and jit_attribute) will, if registered, automatically send notifications to all attached client objects, each time the attribute's value is set. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
		<div id="c74footer">
			&nbsp;&nbsp;Copyright &copy; 2013, <a href="http://www.cycling74.com/">Cycling '74</a>
		</div>
	</body>
</html>
