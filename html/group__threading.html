<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Max 6 API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
</head>
<body>
<div id="top"><!-- do not remove this div! -->
<div id="titlearea">
	<div id="c74header">
		<img src="header.png" height="100" />
	</div>
</div>
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__threading.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Threads</div>  </div>
</div><!--header-->
<div class="contents">

<p>In Max, there are several threads of execution.  
<a href="#details">More...</a></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Collaboration diagram for Threads:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<center><table><tr><td><img src="group__threading.png" border="0" alt="" usemap="#group____threading"/>
<map name="group____threading" id="group____threading">
<area shape="rect" id="node2" href="group__critical.html" title="A critical region is a simple mechanism that prevents multiple threads from accessing at once code pr..." alt="" coords="124,5,238,31"/><area shape="rect" id="node3" href="group__mutex.html" title="Mutexes" alt="" coords="145,55,217,80"/></map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__critical"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__critical.html">Critical Regions</a></td></tr>
<tr class="memdesc:group__critical"><td class="mdescLeft">&#160;</td><td class="mdescRight">A critical region is a simple mechanism that prevents multiple threads from accessing at once code protected by the same critical region. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__mutex"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html">Mutexes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gafca49284437802927af64f9133765571"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafca49284437802927af64f9133765571"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading.html#gafca49284437802927af64f9133765571">ATOMIC_INCREMENT</a>(atomicptr)</td></tr>
<tr class="memdesc:gafca49284437802927af64f9133765571"><td class="mdescLeft">&#160;</td><td class="mdescRight">increment an atomic int valuereturn value of ATOMIC_INCREMENT and ATOMIC_DECREMENT is the *new* value after performing the operation <br /></td></tr>
<tr class="separator:gafca49284437802927af64f9133765571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadee7511403e60b4844f09562d3476c76"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadee7511403e60b4844f09562d3476c76"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading.html#gadee7511403e60b4844f09562d3476c76">ATOMIC_INCREMENT_BARRIER</a>(atomicptr)</td></tr>
<tr class="memdesc:gadee7511403e60b4844f09562d3476c76"><td class="mdescLeft">&#160;</td><td class="mdescRight">increment an atomic int value with a memory barrierreturn value of ATOMIC_INCREMENT and ATOMIC_DECREMENT is the *new* value after performing the operation <br /></td></tr>
<tr class="separator:gadee7511403e60b4844f09562d3476c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd7677871ef0b04a3ca6e65aedd64dee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabd7677871ef0b04a3ca6e65aedd64dee"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading.html#gabd7677871ef0b04a3ca6e65aedd64dee">ATOMIC_DECREMENT</a>(atomicptr)</td></tr>
<tr class="memdesc:gabd7677871ef0b04a3ca6e65aedd64dee"><td class="mdescLeft">&#160;</td><td class="mdescRight">decrement an atomic int valuereturn value of ATOMIC_INCREMENT and ATOMIC_DECREMENT is the *new* value after performing the operation <br /></td></tr>
<tr class="separator:gabd7677871ef0b04a3ca6e65aedd64dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc72531ba76f9014372423cb6ca34db2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacc72531ba76f9014372423cb6ca34db2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading.html#gacc72531ba76f9014372423cb6ca34db2">ATOMIC_DECREMENT_BARRIER</a>(atomicptr)</td></tr>
<tr class="memdesc:gacc72531ba76f9014372423cb6ca34db2"><td class="mdescLeft">&#160;</td><td class="mdescRight">decrement an atomic int value with a memory barrierreturn value of ATOMIC_INCREMENT and ATOMIC_DECREMENT is the *new* value after performing the operation <br /></td></tr>
<tr class="separator:gacc72531ba76f9014372423cb6ca34db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga503de6f3f546ef1dd2bed57a13d9812c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga503de6f3f546ef1dd2bed57a13d9812c"></a>
typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading.html#ga503de6f3f546ef1dd2bed57a13d9812c">t_systhread_mutex</a></td></tr>
<tr class="memdesc:ga503de6f3f546ef1dd2bed57a13d9812c"><td class="mdescLeft">&#160;</td><td class="mdescRight">An opaque mutex handle. <br /></td></tr>
<tr class="separator:ga503de6f3f546ef1dd2bed57a13d9812c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56cc95a6cbd27fada3a74b85a7bc3155"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga56cc95a6cbd27fada3a74b85a7bc3155"></a>
typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading.html#ga56cc95a6cbd27fada3a74b85a7bc3155">t_systhread_cond</a></td></tr>
<tr class="memdesc:ga56cc95a6cbd27fada3a74b85a7bc3155"><td class="mdescLeft">&#160;</td><td class="mdescRight">An opaque cond handle. <br /></td></tr>
<tr class="separator:ga56cc95a6cbd27fada3a74b85a7bc3155"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaa95d9c538a1b25404d19106739db9802"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading.html#gaa95d9c538a1b25404d19106739db9802">e_max_systhread_mutex_flags</a> { <a class="el" href="group__threading.html#ggaa95d9c538a1b25404d19106739db9802ae34f8741b28ee92a4d702bee8671bb32">SYSTHREAD_MUTEX_NORMAL</a>, 
<a class="el" href="group__threading.html#ggaa95d9c538a1b25404d19106739db9802abb3854e7bf495808b4251d1319cdfa45">SYSTHREAD_MUTEX_ERRORCHECK</a>, 
<a class="el" href="group__threading.html#ggaa95d9c538a1b25404d19106739db9802a4fa486d028b3153aac389ed24e63dddb">SYSTHREAD_MUTEX_RECURSIVE</a>
 }</td></tr>
<tr class="memdesc:gaa95d9c538a1b25404d19106739db9802"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__mutex.html#gaa8cae78764c59883566ac4f861dd534e" title="Create a new mutex, which can be used to place thread locks around critical code. ...">systhread_mutex_new()</a> flags  <a href="group__threading.html#gaa95d9c538a1b25404d19106739db9802">More...</a><br /></td></tr>
<tr class="separator:gaa95d9c538a1b25404d19106739db9802"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gabb52201ce22f2636ee0d844a6aae39c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading.html#gabb52201ce22f2636ee0d844a6aae39c9">schedule</a> (void *ob, <a class="el" href="group__datatypes.html#ga4b2c39d5bd0b08acd10bffed77f0e513">method</a> fun, long when, <a class="el" href="structt__symbol.html">t_symbol</a> *sym, short argc, <a class="el" href="structt__atom.html">t_atom</a> *argv)</td></tr>
<tr class="memdesc:gabb52201ce22f2636ee0d844a6aae39c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cause a function to be executed at the timer level at some time in the future.  <a href="#gabb52201ce22f2636ee0d844a6aae39c9">More...</a><br /></td></tr>
<tr class="separator:gabb52201ce22f2636ee0d844a6aae39c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9b66fe2fc601f110bd962a622f1d5a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading.html#gaa9b66fe2fc601f110bd962a622f1d5a0">schedule_delay</a> (void *ob, <a class="el" href="group__datatypes.html#ga4b2c39d5bd0b08acd10bffed77f0e513">method</a> fun, long delay, <a class="el" href="structt__symbol.html">t_symbol</a> *sym, short argc, <a class="el" href="structt__atom.html">t_atom</a> *argv)</td></tr>
<tr class="memdesc:gaa9b66fe2fc601f110bd962a622f1d5a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cause a function to be executed at the timer level at some time in the future specified by a delay offset.  <a href="#gaa9b66fe2fc601f110bd962a622f1d5a0">More...</a><br /></td></tr>
<tr class="separator:gaa9b66fe2fc601f110bd962a622f1d5a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad60dbceb5e50471a3ec76f608a9ea35c"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading.html#gad60dbceb5e50471a3ec76f608a9ea35c">isr</a> (void)</td></tr>
<tr class="memdesc:gad60dbceb5e50471a3ec76f608a9ea35c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether your code is executing in the Max scheduler thread.  <a href="#gad60dbceb5e50471a3ec76f608a9ea35c">More...</a><br /></td></tr>
<tr class="separator:gad60dbceb5e50471a3ec76f608a9ea35c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa24a0c9896f1ad241e45590065c3f643"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading.html#gaa24a0c9896f1ad241e45590065c3f643">defer</a> (void *ob, <a class="el" href="group__datatypes.html#ga4b2c39d5bd0b08acd10bffed77f0e513">method</a> fn, <a class="el" href="structt__symbol.html">t_symbol</a> *sym, short argc, <a class="el" href="structt__atom.html">t_atom</a> *argv)</td></tr>
<tr class="memdesc:gaa24a0c9896f1ad241e45590065c3f643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defer execution of a function to the main thread if (and only if) your function is executing in the scheduler thread.  <a href="#gaa24a0c9896f1ad241e45590065c3f643">More...</a><br /></td></tr>
<tr class="separator:gaa24a0c9896f1ad241e45590065c3f643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga486daa40ddb16f70b663615695d18315"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading.html#ga486daa40ddb16f70b663615695d18315">defer_low</a> (void *ob, <a class="el" href="group__datatypes.html#ga4b2c39d5bd0b08acd10bffed77f0e513">method</a> fn, <a class="el" href="structt__symbol.html">t_symbol</a> *sym, short argc, <a class="el" href="structt__atom.html">t_atom</a> *argv)</td></tr>
<tr class="memdesc:ga486daa40ddb16f70b663615695d18315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defer execution of a function to the back of the queue on the main thread.  <a href="#ga486daa40ddb16f70b663615695d18315">More...</a><br /></td></tr>
<tr class="separator:ga486daa40ddb16f70b663615695d18315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7217fa33811a5ed35b970f504b4e4a79"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading.html#ga7217fa33811a5ed35b970f504b4e4a79">systhread_create</a> (<a class="el" href="group__datatypes.html#ga4b2c39d5bd0b08acd10bffed77f0e513">method</a> entryproc, void *arg, long stacksize, long priority, long flags, <a class="el" href="group__threading.html#ga24a3d6fb3580f2cce023713dd03f056a">t_systhread</a> *thread)</td></tr>
<tr class="memdesc:ga7217fa33811a5ed35b970f504b4e4a79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new thread.  <a href="#ga7217fa33811a5ed35b970f504b4e4a79">More...</a><br /></td></tr>
<tr class="separator:ga7217fa33811a5ed35b970f504b4e4a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacc57aeddc69c01e7562397bdf6f12f5"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading.html#gaacc57aeddc69c01e7562397bdf6f12f5">systhread_terminate</a> (<a class="el" href="group__threading.html#ga24a3d6fb3580f2cce023713dd03f056a">t_systhread</a> thread)</td></tr>
<tr class="memdesc:gaacc57aeddc69c01e7562397bdf6f12f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forcefully kill a thread &ndash; not recommended.  <a href="#gaacc57aeddc69c01e7562397bdf6f12f5">More...</a><br /></td></tr>
<tr class="separator:gaacc57aeddc69c01e7562397bdf6f12f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1ca1694ee14824a56916d8f67d7966b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading.html#gad1ca1694ee14824a56916d8f67d7966b">systhread_sleep</a> (long milliseconds)</td></tr>
<tr class="memdesc:gad1ca1694ee14824a56916d8f67d7966b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspend the execution of the calling thread.  <a href="#gad1ca1694ee14824a56916d8f67d7966b">More...</a><br /></td></tr>
<tr class="separator:gad1ca1694ee14824a56916d8f67d7966b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad448ff5be27ef8233162a0e24751786f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading.html#gad448ff5be27ef8233162a0e24751786f">systhread_exit</a> (long status)</td></tr>
<tr class="memdesc:gad448ff5be27ef8233162a0e24751786f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exit the calling thread.  <a href="#gad448ff5be27ef8233162a0e24751786f">More...</a><br /></td></tr>
<tr class="separator:gad448ff5be27ef8233162a0e24751786f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac24a9db0d7af2343501a4e762d2ce85"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading.html#gaac24a9db0d7af2343501a4e762d2ce85">systhread_join</a> (<a class="el" href="group__threading.html#ga24a3d6fb3580f2cce023713dd03f056a">t_systhread</a> thread, unsigned int *retval)</td></tr>
<tr class="memdesc:gaac24a9db0d7af2343501a4e762d2ce85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for thread to quit and get return value from <a class="el" href="group__threading.html#gad448ff5be27ef8233162a0e24751786f" title="Exit the calling thread. ">systhread_exit()</a>.  <a href="#gaac24a9db0d7af2343501a4e762d2ce85">More...</a><br /></td></tr>
<tr class="separator:gaac24a9db0d7af2343501a4e762d2ce85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga943d19bf724a3cf229b7e8eaaeb56faf"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading.html#ga943d19bf724a3cf229b7e8eaaeb56faf">systhread_detach</a> (<a class="el" href="group__threading.html#ga24a3d6fb3580f2cce023713dd03f056a">t_systhread</a> thread)</td></tr>
<tr class="memdesc:ga943d19bf724a3cf229b7e8eaaeb56faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach a thread.  <a href="#ga943d19bf724a3cf229b7e8eaaeb56faf">More...</a><br /></td></tr>
<tr class="separator:ga943d19bf724a3cf229b7e8eaaeb56faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab76eb3e1668b13483533c4929be5c914"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__threading.html#ga24a3d6fb3580f2cce023713dd03f056a">t_systhread</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading.html#gab76eb3e1668b13483533c4929be5c914">systhread_self</a> (void)</td></tr>
<tr class="memdesc:gab76eb3e1668b13483533c4929be5c914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the thread instance pointer for the calling thread.  <a href="#gab76eb3e1668b13483533c4929be5c914">More...</a><br /></td></tr>
<tr class="separator:gab76eb3e1668b13483533c4929be5c914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e4b35c628d791550e5523c4b554d466"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading.html#ga4e4b35c628d791550e5523c4b554d466">systhread_setpriority</a> (<a class="el" href="group__threading.html#ga24a3d6fb3580f2cce023713dd03f056a">t_systhread</a> thread, int priority)</td></tr>
<tr class="memdesc:ga4e4b35c628d791550e5523c4b554d466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the thread priority for the given thread.  <a href="#ga4e4b35c628d791550e5523c4b554d466">More...</a><br /></td></tr>
<tr class="separator:ga4e4b35c628d791550e5523c4b554d466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf073584f030cffc3a823601173803a95"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading.html#gaf073584f030cffc3a823601173803a95">systhread_getpriority</a> (<a class="el" href="group__threading.html#ga24a3d6fb3580f2cce023713dd03f056a">t_systhread</a> thread)</td></tr>
<tr class="memdesc:gaf073584f030cffc3a823601173803a95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the thread priority for the given thread.  <a href="#gaf073584f030cffc3a823601173803a95">More...</a><br /></td></tr>
<tr class="separator:gaf073584f030cffc3a823601173803a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ed1192e20bccddec517591b4a5f0f91"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading.html#ga7ed1192e20bccddec517591b4a5f0f91">systhread_ismainthread</a> (void)</td></tr>
<tr class="memdesc:ga7ed1192e20bccddec517591b4a5f0f91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check to see if the function currently being executed is in the main thread.  <a href="#ga7ed1192e20bccddec517591b4a5f0f91">More...</a><br /></td></tr>
<tr class="separator:ga7ed1192e20bccddec517591b4a5f0f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bc306a6b164f705e55d1612c5ccfb78"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading.html#ga9bc306a6b164f705e55d1612c5ccfb78">systhread_istimerthread</a> (void)</td></tr>
<tr class="memdesc:ga9bc306a6b164f705e55d1612c5ccfb78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check to see if the function currently being executed is in a scheduler thread.  <a href="#ga9bc306a6b164f705e55d1612c5ccfb78">More...</a><br /></td></tr>
<tr class="separator:ga9bc306a6b164f705e55d1612c5ccfb78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1b536002d2b9deb06b44eb5ab91b744"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading.html#gaa1b536002d2b9deb06b44eb5ab91b744">systhread_isaudiothread</a> (void)</td></tr>
<tr class="memdesc:gaa1b536002d2b9deb06b44eb5ab91b744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check to see if the function currently being executed is in an audio thread.  <a href="#gaa1b536002d2b9deb06b44eb5ab91b744">More...</a><br /></td></tr>
<tr class="separator:gaa1b536002d2b9deb06b44eb5ab91b744"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga24a3d6fb3580f2cce023713dd03f056a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga24a3d6fb3580f2cce023713dd03f056a"></a>
<a class="el" href="group__misc.html#ga06f35de4fc025809ab1cbb06f55b6495">BEGIN_USING_C_LINKAGE</a> typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading.html#ga24a3d6fb3580f2cce023713dd03f056a">t_systhread</a></td></tr>
<tr class="memdesc:ga24a3d6fb3580f2cce023713dd03f056a"><td class="mdescLeft">&#160;</td><td class="mdescRight">An opaque thread instance pointer. <br /></td></tr>
<tr class="separator:ga24a3d6fb3580f2cce023713dd03f056a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>In Max, there are several threads of execution. </p>
<p>The details of these threads are highlighted in the article "Event Priority in Max (Scheduler vs. Queue)" located online at <a href="http://www.cycling74.com/story/2005/5/2/133649/9742">http://www.cycling74.com/story/2005/5/2/133649/9742</a>.</p>
<p>Not all of the details of Max's threading model are expounded here. Most important to understand is that we typically deal the scheduler (which when overdrive is on runs in a separate and high priority thread) and the low priority queue (which always runs in the main application thread).</p>
<dl class="section see"><dt>See also</dt><dd><a href="http://www.cycling74.com/twiki/bin/view/ProductDocumentation/JitterSdkSchedQueue">http://www.cycling74.com/twiki/bin/view/ProductDocumentation/JitterSdkSchedQueue</a> </dd>
<dd>
<a href="http://www.cycling74.com/story/2005/5/2/133649/9742">http://www.cycling74.com/story/2005/5/2/133649/9742</a> </dd></dl>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="gaa95d9c538a1b25404d19106739db9802"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__threading.html#gaa95d9c538a1b25404d19106739db9802">e_max_systhread_mutex_flags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="group__mutex.html#gaa8cae78764c59883566ac4f861dd534e" title="Create a new mutex, which can be used to place thread locks around critical code. ...">systhread_mutex_new()</a> flags </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggaa95d9c538a1b25404d19106739db9802ae34f8741b28ee92a4d702bee8671bb32"></a>SYSTHREAD_MUTEX_NORMAL&#160;</td><td class="fielddoc">
<p>Normal. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaa95d9c538a1b25404d19106739db9802abb3854e7bf495808b4251d1319cdfa45"></a>SYSTHREAD_MUTEX_ERRORCHECK&#160;</td><td class="fielddoc">
<p>Error-checking. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaa95d9c538a1b25404d19106739db9802a4fa486d028b3153aac389ed24e63dddb"></a>SYSTHREAD_MUTEX_RECURSIVE&#160;</td><td class="fielddoc">
<p>Recursive. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaa24a0c9896f1ad241e45590065c3f643"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* defer </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#ga4b2c39d5bd0b08acd10bffed77f0e513">method</a>&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt__symbol.html">t_symbol</a> *&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt__atom.html">t_atom</a> *&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defer execution of a function to the main thread if (and only if) your function is executing in the scheduler thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ob</td><td>First argument passed to the function fun when it executes. </td></tr>
    <tr><td class="paramname">fn</td><td>Function to be called, see below for how it should be declared. </td></tr>
    <tr><td class="paramname">sym</td><td>Second argument passed to the function fun when it executes. </td></tr>
    <tr><td class="paramname">argc</td><td>Count of arguments in argv. argc is also the third argument passed to the function fun when it executes. </td></tr>
    <tr><td class="paramname">argv</td><td>Array containing a variable number of <a class="el" href="structt__atom.html" title="An atom is a typed datum. ">t_atom</a> function arguments. If this argument is non-zero, defer allocates memory to make a copy of the arguments (according to the size passed in argc) and passes the copied array to the function fun when it executes as the fourth argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return values is for internal Cycling '74 use only.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function uses the <a class="el" href="group__threading.html#gad60dbceb5e50471a3ec76f608a9ea35c" title="Determine whether your code is executing in the Max scheduler thread. ">isr()</a> routine to determine whether you're at the Max timer interrupt level (in the scheduler thread). If so, <a class="el" href="group__threading.html#gaa24a0c9896f1ad241e45590065c3f643" title="Defer execution of a function to the main thread if (and only if) your function is executing in the s...">defer()</a> creates a Qelem (see <a class="el" href="group__qelems.html">Qelems</a>), calls <a class="el" href="group__qelems.html#gab5fa3e43e7851d1a2049ee28f5275955" title="Cause a Qelem to execute with a higher priority. ">qelem_front()</a>, and its queue function calls the function fn you passed with the specified arguments. If you're not in the scheduler thread, the function is executed immediately with the arguments. Note that this implies that <a class="el" href="group__threading.html#gaa24a0c9896f1ad241e45590065c3f643" title="Defer execution of a function to the main thread if (and only if) your function is executing in the s...">defer()</a> is not appropriate for using in situations such as Device or File manager I/0 completion routines. The <a class="el" href="group__threading.html#ga486daa40ddb16f70b663615695d18315" title="Defer execution of a function to the back of the queue on the main thread. ">defer_low()</a> function is appropriate however, because it always defers.</dd></dl>
<p>The deferred function should be declared as follows: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;void myobject_do (myObject *client, t_symbol *s, short argc, t_atom *argv);</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__threading.html#ga486daa40ddb16f70b663615695d18315" title="Defer execution of a function to the back of the queue on the main thread. ">defer_low()</a> </dd></dl>

<p>Referenced by <a class="el" href="group__utilitymod.html#ga65b95cf6d8f87c67d0333a6baf17aa63">jit_error_code()</a>, <a class="el" href="group__utilitymod.html#gae0572119ae652a87ae84f181d439d0e9">jit_error_sym()</a>, and <a class="el" href="group__utilitymod.html#ga3b56c14bcf54b8cdc384e8cc95b09c38">jit_post_sym()</a>.</p>

</div>
</div>
<a class="anchor" id="ga486daa40ddb16f70b663615695d18315"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* defer_low </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#ga4b2c39d5bd0b08acd10bffed77f0e513">method</a>&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt__symbol.html">t_symbol</a> *&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt__atom.html">t_atom</a> *&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defer execution of a function to the back of the queue on the main thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ob</td><td>First argument passed to the function fun when it executes. </td></tr>
    <tr><td class="paramname">fn</td><td>Function to be called, see below for how it should be declared. </td></tr>
    <tr><td class="paramname">sym</td><td>Second argument passed to the function fun when it executes. </td></tr>
    <tr><td class="paramname">argc</td><td>Count of arguments in argv. argc is also the third argument passed to the function fun when it executes. </td></tr>
    <tr><td class="paramname">argv</td><td>Array containing a variable number of <a class="el" href="structt__atom.html" title="An atom is a typed datum. ">t_atom</a> function arguments. If this argument is non-zero, defer allocates memory to make a copy of the arguments (according to the size passed in argc) and passes the copied array to the function fun when it executes as the fourth argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return values is for internal Cycling '74 use only.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd><a class="el" href="group__threading.html#ga486daa40ddb16f70b663615695d18315" title="Defer execution of a function to the back of the queue on the main thread. ">defer_low()</a> always defers a call to the function fun whether you are already in the main thread or not, and uses <a class="el" href="group__qelems.html#ga3e292aad133af89a87e167e88cc4a1b5" title="Cause a Qelem to execute. ">qelem_set()</a>, not <a class="el" href="group__qelems.html#gab5fa3e43e7851d1a2049ee28f5275955" title="Cause a Qelem to execute with a higher priority. ">qelem_front()</a>. This function is recommended for responding to messages that will cause your object to open a dialog box, such as read and write.</dd></dl>
<p>The deferred function should be declared as follows: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;void myobject_do (myObject *client, t_symbol *s, short argc, t_atom *argv);</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__threading.html#gaa24a0c9896f1ad241e45590065c3f643" title="Defer execution of a function to the main thread if (and only if) your function is executing in the s...">defer()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gad60dbceb5e50471a3ec76f608a9ea35c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long isr </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether your code is executing in the Max scheduler thread. </p>
<dl class="section return"><dt>Returns</dt><dd>This function returns non-zero if you are within Max's scheduler thread, zero otherwise. Note that if your code sets up other types of interrupt-level callbacks, such as for other types of device drivers used in asynchronous mode, isr will return false. </dd></dl>

</div>
</div>
<a class="anchor" id="gabb52201ce22f2636ee0d844a6aae39c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void schedule </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#ga4b2c39d5bd0b08acd10bffed77f0e513">method</a>&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>when</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt__symbol.html">t_symbol</a> *&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt__atom.html">t_atom</a> *&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cause a function to be executed at the timer level at some time in the future. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ob</td><td>First argument passed to the function fun when it executes. </td></tr>
    <tr><td class="paramname">fun</td><td>Function to be called, see below for how it should be declared. </td></tr>
    <tr><td class="paramname">when</td><td>The logical time that the function fun will be executed. </td></tr>
    <tr><td class="paramname">sym</td><td>Second argument passed to the function fun when it executes. </td></tr>
    <tr><td class="paramname">argc</td><td>Count of arguments in argv. argc is also the third argument passed to the function fun when it executes. </td></tr>
    <tr><td class="paramname">argv</td><td>Array containing a variable number of <a class="el" href="structt__atom.html" title="An atom is a typed datum. ">t_atom</a> function arguments. If this argument is non-zero, defer allocates memory to make a copy of the arguments (according to the size passed in argc) and passes the copied array to the function fun when it executes as the fourth argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><a class="el" href="group__threading.html#gabb52201ce22f2636ee0d844a6aae39c9" title="Cause a function to be executed at the timer level at some time in the future. ">schedule()</a> calls a function at some time in the future. Unlike <a class="el" href="group__threading.html#gaa24a0c9896f1ad241e45590065c3f643" title="Defer execution of a function to the main thread if (and only if) your function is executing in the s...">defer()</a>, the function is called in the scheduling loop when logical time is equal to the specified value when. This means that the function could be called at interrupt level, so it should follow the usual restrictions on interrupt-level conduct. The function fun passed to schedule should be declared as follows:</dd></dl>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;void myobject_do (myObject *client, t_symbol *s, short argc, t_atom *argv); </div>
</div><!-- fragment --><dl class="section remark"><dt>Remarks</dt><dd>One use of <a class="el" href="group__threading.html#gabb52201ce22f2636ee0d844a6aae39c9" title="Cause a function to be executed at the timer level at some time in the future. ">schedule()</a> is as an alternative to using the lockout flag.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__threading.html#gaa24a0c9896f1ad241e45590065c3f643" title="Defer execution of a function to the main thread if (and only if) your function is executing in the s...">defer()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaa9b66fe2fc601f110bd962a622f1d5a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void schedule_delay </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#ga4b2c39d5bd0b08acd10bffed77f0e513">method</a>&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt__symbol.html">t_symbol</a> *&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt__atom.html">t_atom</a> *&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cause a function to be executed at the timer level at some time in the future specified by a delay offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ob</td><td>First argument passed to the function fun when it executes. </td></tr>
    <tr><td class="paramname">fun</td><td>Function to be called, see below for how it should be declared. </td></tr>
    <tr><td class="paramname">delay</td><td>The delay from the current time before the function will be executed. </td></tr>
    <tr><td class="paramname">sym</td><td>Second argument passed to the function fun when it executes. </td></tr>
    <tr><td class="paramname">argc</td><td>Count of arguments in argv. argc is also the third argument passed to the function fun when it executes. </td></tr>
    <tr><td class="paramname">argv</td><td>Array containing a variable number of <a class="el" href="structt__atom.html" title="An atom is a typed datum. ">t_atom</a> function arguments. If this argument is non-zero, <a class="el" href="group__threading.html#gaa9b66fe2fc601f110bd962a622f1d5a0" title="Cause a function to be executed at the timer level at some time in the future specified by a delay of...">schedule_delay()</a> allocates memory to make a copy of the arguments (according to the size passed in argc) and passes the copied array to the function fun when it executes as the fourth argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><a class="el" href="group__threading.html#gaa9b66fe2fc601f110bd962a622f1d5a0" title="Cause a function to be executed at the timer level at some time in the future specified by a delay of...">schedule_delay()</a> is similar to <a class="el" href="group__threading.html#gabb52201ce22f2636ee0d844a6aae39c9" title="Cause a function to be executed at the timer level at some time in the future. ">schedule()</a> but allows you to specify the time as a delay rather than a specific logical time.</dd></dl>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;void myobject_click (t_myobject *x, Point pt, short modifiers) </div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;{ </div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;   t_atom a[1]; </div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;   a[0].a_type = A_LONG; </div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;   a[0].a_w.w_long = Random(); </div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;   schedule_delay(x, myobject_sched, 0 ,0, 1, a); </div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;} </div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;void myobject_sched (t_myobject *x, t_symbol *s, short ac, t_atom *av) </div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;{ </div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;   outlet_int(x-&gt;m_out,av-&gt;a_w.w_long); </div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;} </div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__threading.html#gabb52201ce22f2636ee0d844a6aae39c9" title="Cause a function to be executed at the timer level at some time in the future. ">schedule()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga7217fa33811a5ed35b970f504b4e4a79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long systhread_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#ga4b2c39d5bd0b08acd10bffed77f0e513">method</a>&#160;</td>
          <td class="paramname"><em>entryproc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>stacksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__threading.html#ga24a3d6fb3580f2cce023713dd03f056a">t_systhread</a> *&#160;</td>
          <td class="paramname"><em>thread</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entryproc</td><td>A method to call in the new thread when the thread is created. </td></tr>
    <tr><td class="paramname">arg</td><td>An argument to pass to the method specified for entryproc. Typically this might be a pointer to your object's struct. </td></tr>
    <tr><td class="paramname">stacksize</td><td>Not used. Pass 0 for this argument. </td></tr>
    <tr><td class="paramname">priority</td><td>Pass 0 for default priority. The priority can range from -32 to 32 where -32 is low, 0 is default and 32 is high. </td></tr>
    <tr><td class="paramname">flags</td><td>Not used. Pass 0 for this argument. </td></tr>
    <tr><td class="paramname">thread</td><td>The address of a <a class="el" href="group__threading.html#ga24a3d6fb3580f2cce023713dd03f056a" title="An opaque thread instance pointer. ">t_systhread</a> where this thread's instance pointer will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Max error code as defined in <a class="el" href="group__misc.html#ga0764dd6c02b76cca7d053ae50555d69d" title="Standard values returned by function calls with a return type of t_max_err. ">e_max_errorcodes</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga943d19bf724a3cf229b7e8eaaeb56faf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long systhread_detach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__threading.html#ga24a3d6fb3580f2cce023713dd03f056a">t_systhread</a>&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach a thread. </p>
<p>After detaching a thread you cannot call <a class="el" href="group__threading.html#gaac24a9db0d7af2343501a4e762d2ce85" title="Wait for thread to quit and get return value from systhread_exit(). ">systhread_join()</a> on it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread to join. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Max error code as defined in <a class="el" href="group__misc.html#ga0764dd6c02b76cca7d053ae50555d69d" title="Standard values returned by function calls with a return type of t_max_err. ">e_max_errorcodes</a>.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>You should either call <a class="el" href="group__threading.html#gaac24a9db0d7af2343501a4e762d2ce85" title="Wait for thread to quit and get return value from systhread_exit(). ">systhread_join()</a> on a thread or <a class="el" href="group__threading.html#ga943d19bf724a3cf229b7e8eaaeb56faf" title="Detach a thread. ">systhread_detach()</a> to allow the system to reclaim resources. </dd></dl>

</div>
</div>
<a class="anchor" id="gad448ff5be27ef8233162a0e24751786f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void systhread_exit </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exit the calling thread. </p>
<p>Call this from within a thread made using <a class="el" href="group__threading.html#ga7217fa33811a5ed35b970f504b4e4a79" title="Create a new thread. ">systhread_create()</a> when the thread is no longer needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>You will typically pass 0 for status. This value will be accessible by <a class="el" href="group__threading.html#gaac24a9db0d7af2343501a4e762d2ce85" title="Wait for thread to quit and get return value from systhread_exit(). ">systhread_join()</a>, if needed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf073584f030cffc3a823601173803a95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int systhread_getpriority </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__threading.html#ga24a3d6fb3580f2cce023713dd03f056a">t_systhread</a>&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the thread priority for the given thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread for which to find the priority. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current priority value for the given thread. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa1b536002d2b9deb06b44eb5ab91b744"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short systhread_isaudiothread </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check to see if the function currently being executed is in an audio thread. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the function is being executed in an audio thread, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7ed1192e20bccddec517591b4a5f0f91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short systhread_ismainthread </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check to see if the function currently being executed is in the main thread. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the function is being executed in the main thread, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9bc306a6b164f705e55d1612c5ccfb78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short systhread_istimerthread </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check to see if the function currently being executed is in a scheduler thread. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the function is being executed in a scheduler thread, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="gaac24a9db0d7af2343501a4e762d2ce85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long systhread_join </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__threading.html#ga24a3d6fb3580f2cce023713dd03f056a">t_systhread</a>&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>retval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for thread to quit and get return value from <a class="el" href="group__threading.html#gad448ff5be27ef8233162a0e24751786f" title="Exit the calling thread. ">systhread_exit()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread to join. </td></tr>
    <tr><td class="paramname">retval</td><td>The address of a long to hold the return value (status) from <a class="el" href="group__threading.html#gad448ff5be27ef8233162a0e24751786f" title="Exit the calling thread. ">systhread_exit()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Max error code as defined in <a class="el" href="group__misc.html#ga0764dd6c02b76cca7d053ae50555d69d" title="Standard values returned by function calls with a return type of t_max_err. ">e_max_errorcodes</a>.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If your object is freed, and your thread function accesses memory from your object, then you will obviously have a memory violation. A common use of <a class="el" href="group__threading.html#gaac24a9db0d7af2343501a4e762d2ce85" title="Wait for thread to quit and get return value from systhread_exit(). ">systhread_join()</a> is to prevent this situation by waiting (in your free method) for the thread to exit. </dd></dl>

</div>
</div>
<a class="anchor" id="gab76eb3e1668b13483533c4929be5c914"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__threading.html#ga24a3d6fb3580f2cce023713dd03f056a">t_systhread</a> systhread_self </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the thread instance pointer for the calling thread. </p>
<dl class="section return"><dt>Returns</dt><dd>The thread instance pointer for the thread from which this function is called. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4e4b35c628d791550e5523c4b554d466"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void systhread_setpriority </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__threading.html#ga24a3d6fb3580f2cce023713dd03f056a">t_systhread</a>&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the thread priority for the given thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread for which to set the priority. </td></tr>
    <tr><td class="paramname">priority</td><td>A value in the range -32 to 32 where -32 is lowest, 0 is default, and 32 is highest. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad1ca1694ee14824a56916d8f67d7966b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void systhread_sleep </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>milliseconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suspend the execution of the calling thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">milliseconds</td><td>The number of milliseconds to suspend the execution of the calling thread. The actual amount of time may be longer depending on various factors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaacc57aeddc69c01e7562397bdf6f12f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long systhread_terminate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__threading.html#ga24a3d6fb3580f2cce023713dd03f056a">t_systhread</a>&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forcefully kill a thread &ndash; not recommended. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread to kill. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Max error code as defined in <a class="el" href="group__misc.html#ga0764dd6c02b76cca7d053ae50555d69d" title="Standard values returned by function calls with a return type of t_max_err. ">e_max_errorcodes</a>. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
		<div id="c74footer">
			&nbsp;&nbsp;Copyright &copy; 2013, <a href="http://www.cycling74.com/">Cycling '74</a>
		</div>
	</body>
</html>
