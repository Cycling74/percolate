<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Max 6 API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
</head>
<body>
<div id="top"><!-- do not remove this div! -->
<div id="titlearea">
	<div id="c74header">
		<img src="header.png" height="100" />
	</div>
</div>
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('chapter_msgattached.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Sending Messages, Calling Methods </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Max objects, such as the one you write, are C data structures in which methods are dynamically bound to functions.</p>
<p>Your object's methods are called by Max, but your object can also call methods itself. When you call a method, it is essential to know whether the method you are calling is <b>typed</b> or not.</p>
<p>Calling a typed method requires passing arguments as an array of atoms. Calling an untyped method requires that you know the exact arguments of the C function implementing the method. In both cases, you supply a symbol that names the method.</p>
<p>In the typed method case, Max will take the array of atoms and pass the arguments to the object according to the method's argument type specifier list. For example, if the method is declared to have an argument type specifier list of <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47a002f28879581a6f66ea492b994b96f1e" title="long integer ">A_LONG</a>, 0, the first atom in the array you pass will be converted to an int and passed to the function on the stack. If there are no arguments supplied, invoking a typed method that has <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47a002f28879581a6f66ea492b994b96f1e" title="long integer ">A_LONG</a>, 0 as an argument type specifier will fail. To make typed method calls, use <a class="el" href="group__obj.html#ga443dee482af22e0fe83e68955d367226" title="Sends a type-checked message to an object. ">object_method_typed()</a> or <a class="el" href="group__class__old.html#ga78c60eb0068bce55eaa635e206cba52e" title="Send a typed message directly to a Max object. ">typedmess()</a>.</p>
<p>In the untyped method case, Max merely does a lookup of the symbol in the object, and, if a matching function is found, calls the function with the arguments you pass.</p>
<p>Certain methods you write for your object, such as the assist method for describing your object and the DSP method in audio objects, are declared as untyped using the <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47af48193ec36e53b1507d81c49873c8d7a" title="cannot typecheck args ">A_CANT</a> argument type specifier. This means that Max will not typecheck the arguments you pass to these methods, but, most importantly, a user cannot hook up a message box to your object and send it a message to invoke an untyped method. (Try this for yourself &ndash; send the assist message to a standard Max object.)</p>
<p>When you use an outlet, you're effectively making a typed method call on any objects connected to the outlet.</p>
<h1><a class="anchor" id="chapter_msgattached_attrs"></a>
Attributes</h1>
<p>Attributes are descriptions of data in your object. The standardization of these descriptions permits Max to provide a rich interface to object data, including the pattr system, inspectors, the quick reference menu, @ arguments, etc.</p>
<p>It is essential that you have some understanding of attributes if you are going to write a UI object. But non-UI objects can make use of attributes as well. The discussion below is not specific to UI objects. It does however, use the recently introduced system of macros in ext_obex_util.h (included in ext_obex.h) for defining attributes, as well as describing them using attributes of attributes (attr attrs). You can read more detailed descriptions of the underlying attribute definition mechanisms on a per-function basis in the <a class="el" href="group__attr.html">Attributes</a> reference.</p>
<h2><a class="anchor" id="chapter_msgattached_attr_basics"></a>
Attribute Basics</h2>
<p>While attributes can be defined for a specific instance of an object, it's much more common to define an attribute for a class. In such a case, each instance of the class will have the attribute description, but the value will be instance specific. The discussion here focuses only on class attributes.</p>
<p>When an attribute is declared and is made user-settable, a user can send a message to your object consisting of the attribute name and arguments that represent the new value of the attribute. For example, if you declare an attribute called trackcount, the message trackcount 20 will set it to 20. You don't need to do anything special to obtain this behavior. In addition, user-settable attributes will appear when the user opens the inspector on your object.</p>
<p>If you define your attribute as an offset attribute, you describe its location (and size) within your object's C data structure. Max can then read and write the data directly. You can also define custom getter and setter routines if the attribute's value is more complex than simply a stored number. As a theoretical example, you could have an object with an attribute representing the Earth's population. If this value was not able to be stored inside your object, your custom getter routine could initiate a global census before returning the result. A custom setter for the earth's population might do something nasty if the value was set to zero. If you are not a misanthrope, you can take advantage of the ability to set such an attribute to be read-only.</p>
<h2><a class="anchor" id="chapter_msgattached_attr_def"></a>
Defining Attributes</h2>
<p>Attributes are defined when you are defining methods in your initialization routine. You can define your attributes before your methods if you like, but by convention, they are typically defined after the methods. For each definition, you'll specify the name, size, and offset of the corresponding member in your object's data structure that will hold the data. For example, let's say we have an object defined as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>_myobject {</div>
<div class="line">    <a class="code" href="structt__object.html">t_object</a> m_ob;</div>
<div class="line">    <span class="keywordtype">long</span> m_targetaddress;</div>
<div class="line">    <a class="code" href="structt__symbol.html">t_symbol</a> *m_shipname;</div>
<div class="line">    <span class="keywordtype">char</span> m_compatmode;</div>
<div class="line">} t_myobject;</div>
</div><!-- fragment --><p>We want to create attributes for m_targetaddress, m_shipname, and m_compatmode. For each data type (and a few others), there are macros in ext_obex_util.h that will save a fair amount of typing. So, for example, we can define an attribute for m_targetaddress that uses CLASS_ATTR_LONG. Here are attribute definitions for all of the members of our data structure above.</p>
<div class="fragment"><div class="line"><a class="code" href="group__attr.html#ga43c26d1f717ae67c1634b4ed4df5645c">CLASS_ATTR_LONG</a>(c, <span class="stringliteral">&quot;targetaddress&quot;</span>, 0, t_myobject, m_targetaddress);</div>
<div class="line"><a class="code" href="group__attr.html#gaef468ae67347721c1fd8bc7b54c89845">CLASS_ATTR_SYM</a>(c, <span class="stringliteral">&quot;shipname&quot;</span>, 0, t_myobject, m_shipname);</div>
<div class="line"><a class="code" href="group__attr.html#ga155d0006cea5a22fe0832a9fa52b2814">CLASS_ATTR_CHAR</a>(c, <span class="stringliteral">&quot;compatibilitymode&quot;</span>, 0, t_myobject, m_compatmode);</div>
</div><!-- fragment --><h2><a class="anchor" id="chapter_msgattached_attr_custom"></a>
Attributes With Custom Getters and Setters</h2>
<p>In some cases, it is not enough to have Max read and write data in your object directly. In some cases (as in the world population example above) you may have data you need to calculate before it can be returned as a value. In other cases, you may need to do something to update other object state when an attribute value changes. To handle these challenges, you can define custom attribute getter and setter routines. The getter will be called when the value of your attribute is accessed. The setter will be called when someone changes the value of your attribute.</p>
<p>As an example, suppose we have an object that holds onto an array of numbers, and we want to create an attribute for the size of the array. Since we'll want to resize the array when the attribute value changes, we will define a custom setter for our attribute. The default getter is adequate if we store the array size in our object, but since we want to illustrate how to write an attribute getter, we'll write the code so that the array size is computed from the size of the memory pointer we allocate. First, here is our object's data structure:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>_myobject {</div>
<div class="line">    <a class="code" href="structt__object.html">t_object</a> m_ob;</div>
<div class="line">    <span class="keywordtype">long</span> *m_data;</div>
<div class="line">} t_myobject;</div>
</div><!-- fragment --><p>We also have prototypes for our custom attribute setter and getter:</p>
<div class="fragment"><div class="line"><a class="code" href="group__misc.html#gaace8607dfb500e6dcca022a35fcb8386">t_max_err</a> myobject_size_get(t_myobject *x, <a class="code" href="structt__object.html">t_object</a> *attr, <span class="keywordtype">long</span> *argc, <a class="code" href="structt__atom.html">t_atom</a> **argv);</div>
<div class="line"><a class="code" href="group__misc.html#gaace8607dfb500e6dcca022a35fcb8386">t_max_err</a> myobject_size_set(t_myobject *x, <a class="code" href="structt__object.html">t_object</a> *attr, <span class="keywordtype">long</span> argc, <a class="code" href="structt__atom.html">t_atom</a> *argv);</div>
</div><!-- fragment --><p>Here is how we define our attribute using <a class="el" href="group__attr.html#ga51b1e8466f45d86683437a77be600fb8" title="Specify custom accessor methods for an attribute. ">CLASS_ATTR_ACCESSORS</a> macro to define the custom setter and getter. Because we aren't really using an "offset" due to the custom setter and getter, we can pass any data structure member as a dummy. (Only the default attribute getter and setter will use this offset, and they are out of the picture.)</p>
<div class="fragment"><div class="line"><a class="code" href="group__attr.html#ga43c26d1f717ae67c1634b4ed4df5645c">CLASS_ATTR_LONG</a>(c, <span class="stringliteral">&quot;size&quot;</span>, 0, t_myobject, m_ob);</div>
<div class="line"><a class="code" href="group__attr.html#ga51b1e8466f45d86683437a77be600fb8">CLASS_ATTR_ACCESSORS</a>(c, <span class="stringliteral">&quot;size&quot;</span>, myobject_size_get, myobject_size_set);</div>
</div><!-- fragment --><p>Now, here is an implementation of the custom setter for the array size. For the setter, we use the handy Max API function sysmem_resizeptr so we can effectively "resize" our array and copy the data into it in one step. The setter uses atoms, so we have to obtain the value from the first item in the argv array.</p>
<div class="fragment"><div class="line"><a class="code" href="group__misc.html#gaace8607dfb500e6dcca022a35fcb8386">t_max_err</a> myobject_size_set(t_myobject *x, <a class="code" href="structt__object.html">t_object</a> *attr, <span class="keywordtype">long</span> argc, <a class="code" href="structt__atom.html">t_atom</a> *argv)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">long</span> size = <a class="code" href="group__atom.html#gad5b32f8edd196e0116abed67c4876ae7">atom_getlong</a>(argv);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (size &lt; 0)       <span class="comment">// bad size, don&#39;t change anything</span></div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (x-&gt;m_data)</div>
<div class="line">        x-&gt;m_data = (<span class="keywordtype">long</span> *)<a class="code" href="group__memory.html#gacad6bca165c7b2849fc81d8449245755">sysmem_resizeptr</a>((<span class="keywordtype">char</span> *)x-&gt;m_data, size * <span class="keyword">sizeof</span>(long));</div>
<div class="line">    <span class="keywordflow">else</span>    <span class="comment">// first time alloc</span></div>
<div class="line">        x-&gt;m_data = (<span class="keywordtype">long</span> *)<a class="code" href="group__memory.html#gad6d2540a14c12af221770c2793775a89">sysmem_newptr</a>(size * <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>));</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The getter also uses atoms for access, but we are returning a pointer to an array of atoms. The caller of the getter has the option to pre-allocate the memory (passing in the length in argc and the pointer to the memory in argv) or pass in 0 for argc and set the contents of argv to NULL and have the getter allocate the memory. The easiest way to handle this case is to call the utility function atom_alloc, which will figure out what was passed in and allocate memory for a returned atom if necessary.</p>
<div class="fragment"><div class="line"><a class="code" href="group__misc.html#gaace8607dfb500e6dcca022a35fcb8386">t_max_err</a> myobject_size_get(t_myobject *x, <a class="code" href="structt__object.html">t_object</a> *attr, <span class="keywordtype">long</span> *argc, <a class="code" href="structt__atom.html">t_atom</a> **argv)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">char</span> alloc;</div>
<div class="line">    <span class="keywordtype">long</span> size = 0;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__atom.html#gad1a3b8eed4c311ec41b2d565bf40b002">atom_alloc</a>(argc, argv, &amp;alloc);     <span class="comment">// allocate return atom</span></div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (x-&gt;m_data)</div>
<div class="line">        size = <a class="code" href="group__memory.html#ga4f847713a1bd083030d60e8752d7c28d">sysmem_ptrsize</a>((<span class="keywordtype">char</span> *)x-&gt;m_data) / <span class="keyword">sizeof</span>(long);    <span class="comment">// calculate array size based on ptr size</span></div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__atom.html#ga68c9b634425c7e246734ef4ecd911d1c">atom_setlong</a>(*argv, size);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="chapter_msgattached_receiving"></a>
Receiving Notifications</h1>
<p>As an alternative to writing a custom setter, you can take advantage of the fact that objects receive a "notify" message whenever one of their attributes is changed. The prototype for a notify method is as follows:</p>
<div class="fragment"><div class="line"><a class="code" href="group__misc.html#gaace8607dfb500e6dcca022a35fcb8386">t_max_err</a> myobject_notify(t_myobject *x, <a class="code" href="structt__symbol.html">t_symbol</a> *s, <a class="code" href="structt__symbol.html">t_symbol</a> *msg, <span class="keywordtype">void</span> *sender, <span class="keywordtype">void</span> *data);</div>
</div><!-- fragment --><p>Add the following to your class initialization so your notification method will be called:</p>
<div class="fragment"><div class="line"><a class="code" href="group__class.html#gaab2e3c25868317c8a9c216bbca2c040d">class_addmethod</a>(c, (<a class="code" href="group__datatypes.html#ga4b2c39d5bd0b08acd10bffed77f0e513">method</a>)myobject_notify, <span class="stringliteral">&quot;notify&quot;</span>, <a class="code" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47af48193ec36e53b1507d81c49873c8d7a">A_CANT</a>, 0);</div>
</div><!-- fragment --><p>The notify method can handle a variety of notifications (more documentation on this is coming soon!), but the one we're interested in is "attr_modified" &ndash; the notification type is passed to the notify method in the msg argument. Here is an example of a notify method that prints out the name of the attribute that has been modified. You could take any action instead. To obtain the name, we interpret the data argument to the notify method as an attribute object. As an attribute is a regular Max object, we can use object_method to send it a message. In the case we are sending the message getname to the attribute object to obtain its name.</p>
<div class="fragment"><div class="line"><a class="code" href="group__misc.html#gaace8607dfb500e6dcca022a35fcb8386">t_max_err</a> myobject_notify(t_myobject *x, <a class="code" href="structt__symbol.html">t_symbol</a> *s, <a class="code" href="structt__symbol.html">t_symbol</a> *msg, <span class="keywordtype">void</span> *sender, <span class="keywordtype">void</span> *data)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structt__symbol.html">t_symbol</a> *attrname;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (msg == <a class="code" href="group__symbol.html#ga5d8db08b384aeb76eaee85a15f46fbcb">gensym</a>(<span class="stringliteral">&quot;attr_modified&quot;</span>)) {       <span class="comment">// check notification type</span></div>
<div class="line">        attrname = (<a class="code" href="structt__symbol.html">t_symbol</a> *)<a class="code" href="group__obj.html#gae740749094827ac5adc2b7145db1c596">object_method</a>((<a class="code" href="structt__object.html">t_object</a> *)data, <a class="code" href="group__symbol.html#ga5d8db08b384aeb76eaee85a15f46fbcb">gensym</a>(<span class="stringliteral">&quot;getname&quot;</span>));      <span class="comment">// ask attribute object for name</span></div>
<div class="line">        <a class="code" href="group__console.html#gac8e59004be8d946b6812140cb0a33fb0">object_post</a>((<a class="code" href="structt__object.html">t_object</a> *)x, <span class="stringliteral">&quot;changed attr name is %s&quot;</span>,attrname-&gt;<a class="code" href="structt__symbol.html#ae2bf70cea045897c171f39116bf536c8">s_name</a>);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
		<div id="c74footer">
			&nbsp;&nbsp;Copyright &copy; 2013, <a href="http://www.cycling74.com/">Cycling '74</a>
		</div>
	</body>
</html>
