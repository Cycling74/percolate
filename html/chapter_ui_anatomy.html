<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Max 6 API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
</head>
<body>
<div id="top"><!-- do not remove this div! -->
<div id="titlearea">
	<div id="c74header">
		<img src="header.png" height="100" />
	</div>
</div>
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('chapter_ui_anatomy.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Anatomy of a UI Object </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Max user interface objects are more complex than normal non-user-interface objects.</p>
<p>If you have nothing in particular to display, or do not need to create a unique interface for user interaction or editing, it would be better to avoid writing one. However, if you want the details, we have them for you!</p>
<p>In order to create a user interface object, you'll need to be familiar with <a class="el" href="group__attr.html">Attributes</a>, as they are used extensively. If you examine a toggle object in the inspector in Max, you will see a few attributes that have been defined as belonging to the toggle class, namely:</p>
<ul>
<li>Background Color</li>
<li>Check Color</li>
<li>Border Color</li>
</ul>
<p>We'll show how attributes are defined and described so that the inspector can edit them properly.</p>
<p>In addition to attributes, user interface objects draw in a box and respond to user events such as mouse clicks and keyboard events. We'll show how to implement drawing an object's paint method as well user interaction in the mousedown, mousedrag, and mouseup methods.</p>
<p>This chapter only covers basic drawing of lines and filled rectangles. But you can take advantage of a complete graphics API called jgraphics, intended to be used in a user interface object's paint method. We discuss <a class="el" href="group__jgraphics.html">JGraphics</a> in more detail in a separate chapter. You may also find the jgraphics.h header file descriptions of the set of functions helpful.</p>
<p>The SDK examples contain two user interface projects &ndash; the one we'll discuss in this chapter is called <em>uisimp</em> and is a version of the toggle object with a more complicated check box and user interaction. The second project is called <a href="pictmeter~_8c-source.html">pictmeter~</a>, a more advanced object that uses audio as well as image files.</p>
<p>The uisimp object differs from the toggle object in a couple of ways:</p>
<ul>
<li>it tracks the mouse even when it isn't down and "looks excited" when the mouse passes over it</li>
<li>it tracks the mouse while the user is holding the mouse down to show a sort of "depressed" appearance when turning the toggle on</li>
<li>the new toggle state value is sent out when the mouse is released rather than when the mouse is down. In addition, the uisimp object tracks the mouse and does not change the state if the mouse is released outside of the object's box</li>
<li>it doesn't have rounded corners</li>
<li>it has a solid square for a "checked state" instead of an X</li>
</ul>
<p>Otherwise, it acts largely as the toggle does.</p>
<p>The first thing we suggest you do is build the uisimp object and test it out. Once the object is properly building, type "uisimp" into an object box and you can try it out.</p>
<h1><a class="anchor" id="chapter_ui_anatomy_headers"></a>
Required Headers</h1>
<p>UI objects require that you include two header files, jpatcher_api.h and jgraphics.h:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;jpatcher_api.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;jgraphics.h&quot;</span></div>
</div><!-- fragment --><p>The header file jpatcher_api.h includes data structures and accessor functions required by UI objects. The header file jgraphics.h includes data structures and functions for drawing.</p>
<h1><a class="anchor" id="chapter_ui_anatomy_struct"></a>
UI Object Data Structure</h1>
<p>The first part of a UI object is a <a class="el" href="structt__jbox.html" title="The t_jbox struct provides the header for a Max user-interface object. ">t_jbox</a>, not a <a class="el" href="structt__object.html" title="The structure for the head of any object which wants to have inlets or outlets, or support attributes...">t_object</a>. You should generally avoid direct access to fields of a <a class="el" href="structt__jbox.html" title="The t_jbox struct provides the header for a Max user-interface object. ">t_jbox</a>, particularly when changing values, and use the accessor functions defined in jpatcher_api.h. For example, if you change the rectangle of a box without using the accessor function <a class="el" href="group__jbox.html#gad342cd402e9dade9bb13b813a13f038c" title="Set both the presentation rect and the patching rect. ">jbox_set_rect()</a>, the patcher will not be notified properly and the screen will not update.</p>
<p>Following the <a class="el" href="structt__jbox.html" title="The t_jbox struct provides the header for a Max user-interface object. ">t_jbox</a>, you can add other fields for storing the internal state of your object. In particular, if you are going to be drawing something using color, you will want to create attributes that reference fields holding colors in your object. We'll show you how to do this below. Here is the declaration of the t_uisimp data structure.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>_uisimp</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structt__jbox.html">t_jbox</a> u_box;                       <span class="comment">// header for UI objects</span></div>
<div class="line">    <span class="keywordtype">void</span> *u_out;                        <span class="comment">// outlet pointer</span></div>
<div class="line">    <span class="keywordtype">long</span> u_state;                       <span class="comment">// state (1 or 0)</span></div>
<div class="line">    <span class="keywordtype">char</span> u_mouseover;                   <span class="comment">// is mouse over the object</span></div>
<div class="line">    <span class="keywordtype">char</span> u_mousedowninside;             <span class="comment">// is mouse down within the object</span></div>
<div class="line">    <span class="keywordtype">char</span> u_trackmouse;                  <span class="comment">// if non-zero, track mouse when button not down</span></div>
<div class="line">    <a class="code" href="structt__jrgba.html">t_jrgba</a> u_outline;                  <span class="comment">// outline color</span></div>
<div class="line">    <a class="code" href="structt__jrgba.html">t_jrgba</a> u_check;                    <span class="comment">// check (square) color</span></div>
<div class="line">    <a class="code" href="structt__jrgba.html">t_jrgba</a> u_background;               <span class="comment">// background color</span></div>
<div class="line">    <a class="code" href="structt__jrgba.html">t_jrgba</a> u_hilite;                   <span class="comment">// highlight color (when mouse is over and when clicking to check box)</span></div>
<div class="line">} t_uisimp;</div>
</div><!-- fragment --><p>The <a class="el" href="structt__jrgba.html" title="A color composed of red, green, blue, and alpha components. ">t_jrgba</a> structure defines a color with four doubles for red, green, blue, and alpha. Each component ranges from 0-1. When red, green, and blue are all 0, the color is black; when red, green, and blue are 1, the color is white. By defining color attributes using <a class="el" href="structt__jrgba.html" title="A color composed of red, green, blue, and alpha components. ">t_jrgba</a> structures, you will permit the user to use the standard color picker from the inspector to configure colors for your object.</p>
<p>The structure members u_mouseover and u_mousedowninside are used to signal the code that paints the toggle from the code that handles mouse interaction. We'll discuss this more in the "interaction strategy" section below.</p>
<h1><a class="anchor" id="chapter_ui_anatomy_init"></a>
Initialization Routine for UI Objects</h1>
<p>Once you've declared your object's struct, you'll write your initialization ( <a class="el" href="group__class.html#ga2fa22e46d14006d0de5cde70af1f6221" title="ext_main() is the entry point for an extern to be loaded, which all externs must implement this share...">ext_main()</a> ) routine to set up the class, declaring methods and attributes used by UI objects.</p>
<p>The first addition to the class initialization of a normal Max object you need to make is a call to jbox_initclass(). This adds standard methods and attributes common to all UI objects. Here's how you should to it:</p>
<div class="fragment"><div class="line">c = <a class="code" href="group__class.html#ga3450d7e28cb57dc3819486ff49f019c7">class_new</a>(<span class="stringliteral">&quot;uisimp&quot;</span>, (<a class="code" href="group__datatypes.html#ga4b2c39d5bd0b08acd10bffed77f0e513">method</a>)uisimp_new, (<a class="code" href="group__datatypes.html#ga4b2c39d5bd0b08acd10bffed77f0e513">method</a>)uisimp_free, <span class="keyword">sizeof</span>(t_uisimp), 0L, <a class="code" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47a81c1a8550f038db16a619167a70a79b6">A_GIMME</a>, 0);</div>
<div class="line"></div>
<div class="line">c-&gt;c_flags |= <a class="code" href="group__class.html#gga124a08e1744d9e999211abaa9df9f556aab2bebd8a64110247fa11db1c13ca5eb">CLASS_FLAG_NEWDICTIONARY</a>;</div>
<div class="line">jbox_initclass(c, <a class="code" href="group__jbox.html#gafb46881fa4dbaf5073e1ee6929d7fa9d">JBOX_FIXWIDTH</a> | <a class="code" href="group__jbox.html#ga14cb28210886cfe0df0c34f71338faf8">JBOX_COLOR</a>);</div>
</div><!-- fragment --><p>The line c-&gt;c_flags |= <a class="el" href="group__class.html#gga124a08e1744d9e999211abaa9df9f556aab2bebd8a64110247fa11db1c13ca5eb" title="dictionary based constructor ">CLASS_FLAG_NEWDICTIONARY</a> is required, but the flags passed to jbox_initclass &ndash; <a class="el" href="group__jbox.html#gafb46881fa4dbaf5073e1ee6929d7fa9d" title="give the box a textfield based fix-width (bfixwidth) method ">JBOX_FIXWIDTH</a> and <a class="el" href="group__jbox.html#ga14cb28210886cfe0df0c34f71338faf8" title="support the &quot;color&quot; method for color customization ">JBOX_COLOR</a> &ndash; are optional. <a class="el" href="group__jbox.html#gafb46881fa4dbaf5073e1ee6929d7fa9d" title="give the box a textfield based fix-width (bfixwidth) method ">JBOX_FIXWIDTH</a> means that when your object is selected in a patcher, the Fix Width menu item will be enabled to resize your object to its class's default dimensions. We'll specify the default dimensions in a moment. <a class="el" href="group__jbox.html#ga14cb28210886cfe0df0c34f71338faf8" title="support the &quot;color&quot; method for color customization ">JBOX_COLOR</a> means that your object will be given a color attribute so that it can be edited with the color picked shown by the Color... menu item. This is a way to edit a "basic" color of your object without opening the inspector. If neither of these behaviors apply to your object, feel free to pass 0 for the flags argument to jbox_initclass().</p>
<h1><a class="anchor" id="chapter_ui_anatomy_methods"></a>
UI Object Methods</h1>
<p>Next we need to bind a few standard methods. The only required method for UI objects is paint, which draws the your object's content when its box is visible and needs to be redrawn.</p>
<div class="fragment"><div class="line"><a class="code" href="group__class.html#gaab2e3c25868317c8a9c216bbca2c040d">class_addmethod</a>(c, (<a class="code" href="group__datatypes.html#ga4b2c39d5bd0b08acd10bffed77f0e513">method</a>)uisimp_paint,        <span class="stringliteral">&quot;paint&quot;</span>,    <a class="code" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47af48193ec36e53b1507d81c49873c8d7a">A_CANT</a>, 0);</div>
</div><!-- fragment --><p>We'll discuss the paint method in detail below. It makes use of the <a class="el" href="group__jgraphics.html">JGraphics</a> API, which is described in more detail in its own chapter.</p>
<p>Our uisimp toggle will respond to mouse gestures, so we will define a set of mouse handling methods.</p>
<div class="fragment"><div class="line"><a class="code" href="group__class.html#gaab2e3c25868317c8a9c216bbca2c040d">class_addmethod</a>(c, (<a class="code" href="group__datatypes.html#ga4b2c39d5bd0b08acd10bffed77f0e513">method</a>)uisimp_mousedown,    <span class="stringliteral">&quot;mousedown&quot;</span>,    <a class="code" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47af48193ec36e53b1507d81c49873c8d7a">A_CANT</a>, 0);</div>
<div class="line"><a class="code" href="group__class.html#gaab2e3c25868317c8a9c216bbca2c040d">class_addmethod</a>(c, (<a class="code" href="group__datatypes.html#ga4b2c39d5bd0b08acd10bffed77f0e513">method</a>)uisimp_mousedrag,    <span class="stringliteral">&quot;mousedrag&quot;</span>,    <a class="code" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47af48193ec36e53b1507d81c49873c8d7a">A_CANT</a>, 0);</div>
<div class="line"><a class="code" href="group__class.html#gaab2e3c25868317c8a9c216bbca2c040d">class_addmethod</a>(c, (<a class="code" href="group__datatypes.html#ga4b2c39d5bd0b08acd10bffed77f0e513">method</a>)uisimp_mouseup,      <span class="stringliteral">&quot;mouseup&quot;</span>,      <a class="code" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47af48193ec36e53b1507d81c49873c8d7a">A_CANT</a>, 0);</div>
<div class="line"><a class="code" href="group__class.html#gaab2e3c25868317c8a9c216bbca2c040d">class_addmethod</a>(c, (<a class="code" href="group__datatypes.html#ga4b2c39d5bd0b08acd10bffed77f0e513">method</a>)uisimp_mouseenter,   <span class="stringliteral">&quot;mouseenter&quot;</span>,   <a class="code" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47af48193ec36e53b1507d81c49873c8d7a">A_CANT</a>, 0);</div>
<div class="line"><a class="code" href="group__class.html#gaab2e3c25868317c8a9c216bbca2c040d">class_addmethod</a>(c, (<a class="code" href="group__datatypes.html#ga4b2c39d5bd0b08acd10bffed77f0e513">method</a>)uisimp_mouseleave,   <span class="stringliteral">&quot;mouseleave&quot;</span>,   <a class="code" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47af48193ec36e53b1507d81c49873c8d7a">A_CANT</a>, 0);</div>
<div class="line"><a class="code" href="group__class.html#gaab2e3c25868317c8a9c216bbca2c040d">class_addmethod</a>(c, (<a class="code" href="group__datatypes.html#ga4b2c39d5bd0b08acd10bffed77f0e513">method</a>)uisimp_mousemove,    <span class="stringliteral">&quot;mousemove&quot;</span>,    <a class="code" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47af48193ec36e53b1507d81c49873c8d7a">A_CANT</a>, 0);</div>
<div class="line"><a class="code" href="group__class.html#gaab2e3c25868317c8a9c216bbca2c040d">class_addmethod</a>(c, (<a class="code" href="group__datatypes.html#ga4b2c39d5bd0b08acd10bffed77f0e513">method</a>)uisimp_mousewheel,   <span class="stringliteral">&quot;mousewheel&quot;</span>,   <a class="code" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47af48193ec36e53b1507d81c49873c8d7a">A_CANT</a>, 0);</div>
</div><!-- fragment --><p>mousedown is sent to your object when the user clicks on your object &ndash; in other words, when the mouse is moved over the object and the primary mouse button is depressed. mousedrag is sent after an initial mousedown when the mouse moves and the button is still held down from the click. mouseup is sent when the mouse button is released after a mousedown is sent. mouseenter is sent when the mouse button is not down and the mouse moves into your object's box. mousemove is sent &ndash; after a mouseenter &ndash; when the mouse button is not down but the mouse position changes inside your object's box. mouseleave is sent when the mouse button is not down and the mouse position moves from being over your object's box to being outside of it. mousewheel is sent when information about the scrollwheel on the mouse (or scrolling from another source such as a trackpad) is transmitted while the cursor is hovering over your object.</p>
<p>You are not obligated to respond to any of these messages. You could, for example, only respond to mousedown and ignore the other messages.</p>
<p>It might be helpful to summarize mouse messages in the following "rules" (although normally it's not necessary to think about them explicitly):</p>
<ul>
<li>mousedown will always be followed by mouseup, but not necessarily by mousedrag if the button press is rapid and there is no movement while the mouse button is pressed.</li>
<li>mouseenter will always be followed by mouseleave, but</li>
<li>mouseenter will always precede mousemove</li>
<li>mouseleave will be sent only after a mouseenter is sent</li>
<li>You cannot count on any particular relationship between the mousedown / mousedrag / mouseup sequence and the mouseenter / mousemove / mouseleave sequence.</li>
</ul>
<p>We'll look at the actual implementation of mouse handling methods below.</p>
<h1><a class="anchor" id="chapter_ui_anatomy_attributes"></a>
Defining Attributes</h1>
<p>After the declaration of standard methods, your object will define its own attributes. By using what we call "attribute attributes" you can further describe attributes so that they can be appropriately displayed and edited in the inspector as well as saved in a patcher (or not). You can also set default values for attributes that are automatically copied to your object when it is instantiated, and mark an attribute so that your object is redrawn when its value changes.</p>
<p>As a convenience, we've defined a series of macros in ext_obex_util.h (which is included when your object includes ext_obex.h) that reduce the amount of typing needed to define attributes and attribute attributes.</p>
<p>Most UI object attributes are offset attributes; that is, they reference a location in your object's data structure by offset and size. As an example, uisimp has a char offset attribute called trackmouse that specifies whether the object will change the object's appearance when the mouse moves over it. Here's how this is defined:</p>
<div class="fragment"><div class="line"><a class="code" href="group__attr.html#ga155d0006cea5a22fe0832a9fa52b2814">CLASS_ATTR_CHAR</a>(c, <span class="stringliteral">&quot;trackmouse&quot;</span>, 0, t_uisimp, u_trackmouse);</div>
<div class="line"><a class="code" href="group__attr.html#ga1a55732bfe15aff297a7a025ce578d6e">CLASS_ATTR_STYLE_LABEL</a>(c, <span class="stringliteral">&quot;trackmouse&quot;</span>, 0, <span class="stringliteral">&quot;onoff&quot;</span>, <span class="stringliteral">&quot;Track Mouse&quot;</span>);</div>
<div class="line"><a class="code" href="group__attr.html#gaf56dc31d0defad3cdc1ee60b611acc79">CLASS_ATTR_SAVE</a>(c, <span class="stringliteral">&quot;trackmouse&quot;</span>, 0);</div>
</div><!-- fragment --><p>The first line, <a class="el" href="group__attr.html#ga155d0006cea5a22fe0832a9fa52b2814" title="Create a char attribute and add it to a Max class. ">CLASS_ATTR_CHAR</a>, defines a char-sized offset attribute. If you look at the declaration of t_uisimp, you can see that the u_trackmouse field is declared to be a char. The <a class="el" href="group__attr.html#ga155d0006cea5a22fe0832a9fa52b2814" title="Create a char attribute and add it to a Max class. ">CLASS_ATTR_CHAR</a> macro take five arguments.</p>
<ul>
<li>The first argument is the class for which the attribute is being declared.</li>
<li>The second argument is the name of the attribute. You can use send a message to your object with this name and a value and set the attribute.</li>
<li>The third argument is a collection of attribute flags. For the attributes (and attribute attributes) we'll be defining in the uisimp object, the flags will be 0, but you can use them to make attributes read-only with <a class="el" href="group__attr.html#ggaf296cfc6741bb19207f6ed8062809115a82e9ec2c8a764eaa9f1fed1bcf611318" title="The attribute cannot be set by max message when used inside of a CLASS_BOX object, but can be set from C code. ">ATTR_SET_OPAQUE_USER</a>.</li>
<li>The fourth argument is the name of your object's structure containing the field you want to use for the attribute</li>
<li>The fifth argument is the field name you want to use for the attribute</li>
</ul>
<p>The fourth and fifth arguments are used to calculate the offset of the beginning of the field from the beginning of the structure. This allows the attribute to read and write the memory occupied by the field directly.</p>
<p>The second line, <a class="el" href="group__attr.html#ga1a55732bfe15aff297a7a025ce578d6e" title="A convenience wrapper for CLASS_ATTR_STYLE, and CLASS_ATTR_LABEL. ">CLASS_ATTR_STYLE_LABEL</a>, defines some attribute attributes for the trackmouse attribute. THis macro takes five arguments as well:</p>
<ul>
<li>The first argument is the class for which the attribute attributes are being declared.</li>
<li>The second argument is the name of the attribute, which should have already been defined by a <a class="el" href="group__attr.html#ga155d0006cea5a22fe0832a9fa52b2814" title="Create a char attribute and add it to a Max class. ">CLASS_ATTR_CHAR</a> or similar attribute declaration</li>
<li>The third argument is usually 0 &ndash; it is an attribute flags argument for the attribute attributes</li>
<li>The fourth argument is the style of the attribute. "onoff" is used here for a setting in your object that will be a toggle. By using the onoff style the trackmouse attribute will appear with a checkbox in the inspector window. Effectively, this macro defines an attribute called "style" that is attached to the "trackmouse" attribute and set its value to the symbol "onoff" in one step.</li>
<li>The fifth argument is a string used as a descriptive label for the attribute that appears in the inspector and other places in the Max user interface. If you don't supply a label, the attribute name will be shown. The string is used as the value of a newly created "label" attribute attribute.</li>
</ul>
<p>The category attribute attribute is used to organize your object's attributes in the inspector window. For the trackmouse attribute, we use the "Behavior" category, and for the color attributes discussed below, we use "Color" &ndash; look at the inspector category tabs for a few UI objects that come with Max for suggested standard category names. You're free to create your own.</p>
<p>To define a category for a single attribute, you can use the <a class="el" href="group__attr.html#ga1bae4d6ba42e2a7cc9e1bc648ccfb421" title="Add a new attribute to the specified attribute to specify a category to which the attribute is assign...">CLASS_ATTR_CATEGORY</a> macro:</p>
<div class="fragment"><div class="line"><a class="code" href="group__attr.html#ga1bae4d6ba42e2a7cc9e1bc648ccfb421">CLASS_ATTR_CATEGORY</a>(c, <span class="stringliteral">&quot;trackmouse&quot;</span>, 0, <span class="stringliteral">&quot;Behavior&quot;</span>);</div>
</div><!-- fragment --><p>To define a category for a series of attributes, you can use <a class="el" href="group__attr.html#ga51ce88a6d20e819ad703514e583e5562" title="Create an attribute, and add it to all following attribute declarations. ">CLASS_STICKY_ATTR</a>, which applies the current value of a specified attribute attribute to any attributes subsequently defined, until a <a class="el" href="group__attr.html#gadf3ca4c22b0273a96f5644788489970b" title="Close a CLASS_STICKY_ATTR block. ">CLASS_STICKY_ATTR_CLEAR</a> is set for an attribute attribute name. <a class="el" href="group__attr.html#ga51ce88a6d20e819ad703514e583e5562" title="Create an attribute, and add it to all following attribute declarations. ">CLASS_STICKY_ATTR</a> is used in uisimp to apply the "Color" category to a set of three color attributes.</p>
<div class="fragment"><div class="line"><a class="code" href="group__attr.html#ga51ce88a6d20e819ad703514e583e5562">CLASS_STICKY_ATTR</a>(c, <span class="stringliteral">&quot;category&quot;</span>, 0, <span class="stringliteral">&quot;Color&quot;</span>);</div>
</div><!-- fragment --><p>Color attributes are defined using <a class="el" href="group__attr.html#ga24f3c54d0847a6e117a3a48beb44efac" title="Create a color (t_jrgba) attribute and add it to a Max class. ">CLASS_ATTR_RGBA</a>. The uisimp object defines four color attributes. Here is the first, called bgcolor:</p>
<div class="fragment"><div class="line"><a class="code" href="group__attr.html#ga24f3c54d0847a6e117a3a48beb44efac">CLASS_ATTR_RGBA</a>(c, <span class="stringliteral">&quot;bgcolor&quot;</span>, 0, t_uisimp, u_background);</div>
<div class="line"><a class="code" href="group__attr.html#gaa341fe624851ca5eda03361822bb5e33">CLASS_ATTR_DEFAULTNAME_SAVE_PAINT</a>(c, <span class="stringliteral">&quot;bgcolor&quot;</span>, 0, <span class="stringliteral">&quot;1. 1. 1. 1.&quot;</span>);</div>
<div class="line"><a class="code" href="group__attr.html#ga1a55732bfe15aff297a7a025ce578d6e">CLASS_ATTR_STYLE_LABEL</a>(c,<span class="stringliteral">&quot;bgcolor&quot;</span>,0,<span class="stringliteral">&quot;rgba&quot;</span>,<span class="stringliteral">&quot;Background Color&quot;</span>);</div>
</div><!-- fragment --><p>The difference between <a class="el" href="group__attr.html#ga24f3c54d0847a6e117a3a48beb44efac" title="Create a color (t_jrgba) attribute and add it to a Max class. ">CLASS_ATTR_RGBA</a> and <a class="el" href="group__attr.html#ga155d0006cea5a22fe0832a9fa52b2814" title="Create a char attribute and add it to a Max class. ">CLASS_ATTR_CHAR</a> for defining an attribute is that <a class="el" href="group__attr.html#ga24f3c54d0847a6e117a3a48beb44efac" title="Create a color (t_jrgba) attribute and add it to a Max class. ">CLASS_ATTR_RGBA</a> expects the name of a structure member declared of type <a class="el" href="structt__jrgba.html" title="A color composed of red, green, blue, and alpha components. ">t_jrgba</a> rather than type char. When set, the attribute will assign values to the four doubles that make up the components of the color.</p>
<p>The next line uses the <a class="el" href="group__attr.html#gaa341fe624851ca5eda03361822bb5e33" title="A convenience wrapper for CLASS_ATTR_DEFAULTNAME, CLASS_ATTR_SAVE, and CLASS_ATTR_PAINT. ">CLASS_ATTR_DEFAULTNAME_SAVE_PAINT</a> macro. This sets three things about the bgcolor attribute. First it says that the color attribute bgcolor can be assigned a default value via the object defaults window. So, if you don't like the standard white defined by the object, you can assign you own color for the background color of all newly created uisimp objects. The four values 1 1 1 1 supplied as the last argument to <a class="el" href="group__attr.html#gaa341fe624851ca5eda03361822bb5e33" title="A convenience wrapper for CLASS_ATTR_DEFAULTNAME, CLASS_ATTR_SAVE, and CLASS_ATTR_PAINT. ">CLASS_ATTR_DEFAULTNAME_SAVE_PAINT</a> specify the "standard" default value that will be used for the bgcolor attribute in the absence of any overrides from the user.</p>
<p>The SAVE aspect of this macro specifies that this attribute's values should be saved with the object in a patcher. A patcher file saves an object's class, location and connections, but it can also save the object's appearance or any other attribute value you specify, by using the "save" attribute attribute.</p>
<p>The PAINT aspect of this macro provides the ability to have your object redrawn whenever this attribute (bgcolor) changes. However, to implement auto-repainting on attribute changes, you'll need to add the following code when initializing your class:</p>
<div class="fragment"><div class="line"><a class="code" href="group__class.html#gaab2e3c25868317c8a9c216bbca2c040d">class_addmethod</a>(c, (<a class="code" href="group__datatypes.html#ga4b2c39d5bd0b08acd10bffed77f0e513">method</a>)<a class="code" href="group__jbox.html#ga9aa791abf47ea1cb276c5a867665a52a">jbox_notify</a>, <span class="stringliteral">&quot;notify&quot;</span>, <a class="code" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47af48193ec36e53b1507d81c49873c8d7a">A_CANT</a>, 0);</div>
</div><!-- fragment --><p>The function <a class="el" href="group__jbox.html#ga9aa791abf47ea1cb276c5a867665a52a" title="Send a notification to a box. ">jbox_notify()</a> will determine whether an attribute that has caused a change notification to be sent has its paint attribute attribute set, and if so, will call <a class="el" href="group__jbox.html#ga92b553f8adc9994553590bbbcfd7e49d" title="Request that your object/box be re-drawn by Max. ">jbox_redraw()</a>. If you write your own notify method because you want to respond to changes in attributes or other environment changes, you *must* call <a class="el" href="group__jbox.html#ga9aa791abf47ea1cb276c5a867665a52a" title="Send a notification to a box. ">jbox_notify()</a> inside of it.</p>
<h2><a class="anchor" id="chapter_ui_anatomy_attributes_color"></a>
Standard Color Attribute</h2>
<p>At the beginning of our initialization routine, we passed <a class="el" href="group__jbox.html#ga14cb28210886cfe0df0c34f71338faf8" title="support the &quot;color&quot; method for color customization ">JBOX_COLOR</a> as a flag to jbox_initclass(). This adds an attribute to our object called color, which uses storage provided in the <a class="el" href="structt__jbox.html" title="The t_jbox struct provides the header for a Max user-interface object. ">t_jbox</a> to keep track of a color for us. The color attribute is a standard name for the "most basic" color your object uses, and if you define it, the Color menu item in the Object menu will be enabled when your object is selected, permitting the user to change the color without opening the inspector.</p>
<p>If you use <a class="el" href="group__jbox.html#ga14cb28210886cfe0df0c34f71338faf8" title="support the &quot;color&quot; method for color customization ">JBOX_COLOR</a>, you don't need to define the color attribute using <a class="el" href="group__attr.html#ga24f3c54d0847a6e117a3a48beb44efac" title="Create a color (t_jrgba) attribute and add it to a Max class. ">CLASS_ATTR_RGBA</a> &ndash; jbox_initclass() will do it for you. However, the color attribute comes unadorned, so you are free to enhance it with attribute attributes. Here's what uisimp does:</p>
<div class="fragment"><div class="line"><a class="code" href="group__attr.html#gaa341fe624851ca5eda03361822bb5e33">CLASS_ATTR_DEFAULTNAME_SAVE_PAINT</a>(c, <span class="stringliteral">&quot;color&quot;</span>, 0, <span class="stringliteral">&quot;0. 0. 0. 1.&quot;</span>);</div>
<div class="line"><a class="code" href="group__attr.html#ga1a55732bfe15aff297a7a025ce578d6e">CLASS_ATTR_STYLE_LABEL</a>(c,<span class="stringliteral">&quot;color&quot;</span>,0,<span class="stringliteral">&quot;rgba&quot;</span>,<span class="stringliteral">&quot;Check Color&quot;</span>);</div>
</div><!-- fragment --><h2><a class="anchor" id="chapter_ui_anatomy_attributes_size"></a>
Setting a Default Size</h2>
<p>Another attribute defined for your object by jbox_initclass() is called patching_rect. It holds the dimensions of your object's box. If you want to set a standard size for new instances of your object, you can give the patching_rect a set of default values. Use 0 0 for the first two values (x and y position) and use the next two values to define the width and height. We want a small square to be the default size for uisimp, so we use <a class="el" href="group__attr.html#ga91196b43f49d6769e6fe2df99f5c7c77" title="Add a new attribute to the specified attribute to specify a default value. ">CLASS_ATTR_DEFAULT</a> to assign a default value to the patching_rect attribute as follows:</p>
<div class="fragment"><div class="line"><a class="code" href="group__attr.html#ga91196b43f49d6769e6fe2df99f5c7c77">CLASS_ATTR_DEFAULT</a>(c,<span class="stringliteral">&quot;patching_rect&quot;</span>,0, <span class="stringliteral">&quot;0. 0. 20. 20.&quot;</span>);</div>
</div><!-- fragment --><h1><a class="anchor" id="chapter_ui_anatomy_new"></a>
New Instance Routine</h1>
<p>The UI object new instance routine is more complicated than that of a normal Max object. Each UI object is passed a <a class="el" href="structt__dictionary.html" title="The dictionary object. ">t_dictionary</a> (a hierarchically structured collection of data accessed by symbolic names) containing the information needed to instantiate an instance. For UI objects, data elements in the dictionary correspond to attribute values. For example, if your object saved an attribute called "bgcolor" you will be able to access the saved value in your new instance routine from the dictionary using the same name bgcolor.</p>
<p>If the instance is being created from the object palette or by the typing the name of your object into an object box, the dictionary will be filled in with default values. If the object is being created by reading a patcher file, the dictionary will be filled in with the saved attributes stored in the file. In most cases, you don't need to work with the dictionary directly, unless you've added proprietary non-attribute information to your object's dictionary that you want to look for and extract. However, you do need to pass the dictionary to some standard routines, and initialize everything in the right order.</p>
<p>Let's take a look at the pattern you should follow for your object's new instance routine.</p>
<p>First, the new instance routine is declared as follows:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> *uisimp_new(<a class="code" href="structt__symbol.html">t_symbol</a> *s, <span class="keywordtype">long</span> argc, <a class="code" href="structt__atom.html">t_atom</a> *argv);</div>
</div><!-- fragment --><p>We will get the dictionary that defines the object out of the arguments passed in argc, argv. (The symbol argument s is the name of the object.) If obtaining the dictionary fails, we should return NULL to indicate we didn't make an instance.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> *uisimp_new(<a class="code" href="structt__symbol.html">t_symbol</a> *s, <span class="keywordtype">long</span> argc, <a class="code" href="structt__atom.html">t_atom</a> *argv);</div>
<div class="line">{</div>
<div class="line">    t_uisimp *x = NULL;</div>
<div class="line">    <a class="code" href="structt__dictionary.html">t_dictionary</a> *d = NULL;</div>
<div class="line">    <span class="keywordtype">long</span> boxflags;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (!(d = <a class="code" href="group__obj.html#ga6122e56af8de90fa7aad43ee405c6bb6">object_dictionaryarg</a>(argc,argv)))</div>
<div class="line">        <span class="keywordflow">return</span> NULL;</div>
</div><!-- fragment --><p>Next, we allocate a new instance of the object's class:</p>
<div class="fragment"><div class="line">x = (t_uisimp *)<a class="code" href="group__obj.html#gacb89ef27c34b45e9037d877375804284">object_alloc</a>(s_uisimp_class);</div>
</div><!-- fragment --><p>Then we need to initialize the options for our box. Our object uses the options that are not commented out.</p>
<div class="fragment"><div class="line">boxflags = 0</div>
<div class="line">        | <a class="code" href="group__jbox.html#ga9f21c69e60543de2ecbcc94db526134b">JBOX_DRAWFIRSTIN</a></div>
<div class="line">        | <a class="code" href="group__jbox.html#ga5b6543cfc10a8912a82cebada525a770">JBOX_NODRAWBOX</a></div>
<div class="line">        | <a class="code" href="group__jbox.html#ga651b41a98977ffddd7ca2be78d01f37b">JBOX_DRAWINLAST</a></div>
<div class="line">        | <a class="code" href="group__jbox.html#ga3a5253e4b79d030934557351547c71ba">JBOX_TRANSPARENT</a></div>
<div class="line"><span class="comment">//      | JBOX_NOGROW</span></div>
<div class="line">        | <a class="code" href="group__jbox.html#gaf151bcea416076c6811b84bd5cbaf68f">JBOX_GROWY</a></div>
<div class="line"><span class="comment">//      | JBOX_GROWBOTH</span></div>
<div class="line"><span class="comment">//      | JBOX_HILITE</span></div>
<div class="line"><span class="comment">//      | JBOX_BACKGROUND</span></div>
<div class="line">        | <a class="code" href="group__jbox.html#ga73e68b629cf1778a8a6e7a6685d98df6">JBOX_DRAWBACKGROUND</a></div>
<div class="line"><span class="comment">//      | JBOX_NOFLOATINSPECTOR</span></div>
<div class="line"><span class="comment">//      | JBOX_MOUSEDRAGDELTA</span></div>
<div class="line"><span class="comment">//      | JBOX_TEXTFIELD</span></div>
<div class="line">        ;</div>
</div><!-- fragment --><p>Here is some more detail about each of the box flags.</p>
<p>We pass the flags along with a pointer to our newly created instance and the argc, argv arguments to <a class="el" href="group__jbox.html#gaaa460d02ca3d22c54368ade59d8e330b" title="Set up your UI object&#39;s t_jbox member. ">jbox_new()</a>. The name is a little misleading. <a class="el" href="group__jbox.html#gaaa460d02ca3d22c54368ade59d8e330b" title="Set up your UI object&#39;s t_jbox member. ">jbox_new()</a> does not instantiate your box. As we explained above, your UI object has a <a class="el" href="structt__jbox.html" title="The t_jbox struct provides the header for a Max user-interface object. ">t_jbox</a> at the beginning. <a class="el" href="group__jbox.html#gaaa460d02ca3d22c54368ade59d8e330b" title="Set up your UI object&#39;s t_jbox member. ">jbox_new()</a> just initializes the <a class="el" href="structt__jbox.html" title="The t_jbox struct provides the header for a Max user-interface object. ">t_jbox</a> for you. <a class="el" href="group__jbox.html#gaaa460d02ca3d22c54368ade59d8e330b" title="Set up your UI object&#39;s t_jbox member. ">jbox_new()</a> doesn't know about the other stuff in your object's data structure that comes after the <a class="el" href="structt__jbox.html" title="The t_jbox struct provides the header for a Max user-interface object. ">t_jbox</a>. You'll have to initialize the extra items yourself.</p>
<div class="fragment"><div class="line"><a class="code" href="group__jbox.html#gaaa460d02ca3d22c54368ade59d8e330b">jbox_new</a>((<a class="code" href="structt__jbox.html">t_jbox</a> *)x, boxflags, argc, argv);</div>
</div><!-- fragment --><p>Once <a class="el" href="group__jbox.html#gaaa460d02ca3d22c54368ade59d8e330b" title="Set up your UI object&#39;s t_jbox member. ">jbox_new()</a> has been called, you then assign the b_firstin pointer of your <a class="el" href="structt__jbox.html" title="The t_jbox struct provides the header for a Max user-interface object. ">t_jbox</a> header to point to your object. Essentially this assigns the object that will receive messages from objects connected to your leftmost inlet (as well as other inlets via inlets or proxies you create). This step is easily forgotten and will cause most things not to work until you remember it. <a class="el" href="group__jbox.html#gaaa460d02ca3d22c54368ade59d8e330b" title="Set up your UI object&#39;s t_jbox member. ">jbox_new()</a> will obtain the attributes common to all boxes such as the patching_rect, and assign them to your object for you.</p>
<div class="fragment"><div class="line">x-&gt;u_box.b_firstin = (<span class="keywordtype">void</span> *)x;</div>
</div><!-- fragment --><p>Next, you are free to initialize any members of your object's data structure, as well as declare inlets. These steps are the same for UI objects as for non-UI objects.</p>
<div class="fragment"><div class="line">x-&gt;u_mousedowninside = x-&gt;u_mouseover = x-&gt;u_state = 0;</div>
<div class="line">x-&gt;u_out = <a class="code" href="group__inout.html#ga9b8d897c728eeafa5638d4fc16ff704e">intout</a>((<a class="code" href="structt__object.html">t_object</a> *)x);</div>
</div><!-- fragment --><p>Once your object is in a safe initialized state, call <a class="el" href="group__attr.html#ga3109d643addc97cb6a07785a9170e2e3" title="Set attributes for an object that are defined in a dictionary. ">attr_dictionary_process()</a> if you've defined any attributes. This will find the attributes in the dictionary your object received, then set them to the values stored in the dictionary. There is no way to guarantee the order in which the attributes will be set. If this a problem, you can obtain the attribute values "by hand" and assign them to your object.</p>
<p>Note that you do not need to call <a class="el" href="group__attr.html#ga3109d643addc97cb6a07785a9170e2e3" title="Set attributes for an object that are defined in a dictionary. ">attr_dictionary_process()</a> if you have not defined any attributes. <a class="el" href="group__jbox.html#gaaa460d02ca3d22c54368ade59d8e330b" title="Set up your UI object&#39;s t_jbox member. ">jbox_new()</a> will take care of setting all attributes common to all UI objects.</p>
<div class="fragment"><div class="line"><a class="code" href="group__attr.html#ga3109d643addc97cb6a07785a9170e2e3">attr_dictionary_process</a>(x,d);</div>
</div><!-- fragment --><p>As the last thing to do before returning your newly created UI object, and more specifically after you've initialized everything to finalize the appearance of your object, call <a class="el" href="group__jbox.html#gabea75e4d5243003070cb2de04b81d3d1" title="Mark the box ready to be accessed and drawn by Max. ">jbox_ready()</a>. <a class="el" href="group__jbox.html#gabea75e4d5243003070cb2de04b81d3d1" title="Mark the box ready to be accessed and drawn by Max. ">jbox_ready()</a> will paint your object, calculate the positions of the inlets and outlets, and perform other initialization tasks to ensure that your box is a proper member of the visible patcher.</p>
<p>If your object does not appear when you instantiate it, you should check whether you do not have a <a class="el" href="group__jbox.html#gabea75e4d5243003070cb2de04b81d3d1" title="Mark the box ready to be accessed and drawn by Max. ">jbox_ready()</a> call.</p>
<div class="fragment"><div class="line"><a class="code" href="group__jbox.html#gabea75e4d5243003070cb2de04b81d3d1">jbox_ready</a>((<a class="code" href="structt__jbox.html">t_jbox</a> *)x);</div>
</div><!-- fragment --><p>Finally, as with any instance creation routine, the newly created object will be returned.</p>
<div class="fragment"><div class="line"><span class="keywordflow">return</span> x;</div>
</div><!-- fragment --><h1><a class="anchor" id="chapter_ui_anatomy_updating"></a>
Dynamic Updating</h1>
<p>Drawing anything to the screen must be limited to your paint method (this was not the case with the previous UI object API in Max). If you want to redraw something, you need to call <a class="el" href="group__jbox.html#ga92b553f8adc9994553590bbbcfd7e49d" title="Request that your object/box be re-drawn by Max. ">jbox_redraw()</a> to cause the screen to be redrawn. This is necessary because your object is part of a compositing user interface that must be managed by the patcher as a whole to avoid screen artifacts. The <a class="el" href="group__jbox.html#ga92b553f8adc9994553590bbbcfd7e49d" title="Request that your object/box be re-drawn by Max. ">jbox_redraw()</a> routine calculates the area of the screen that needs to be redrawn, then informs the Mac or Windows "window manager" to mark this area as invalid. At some later point in time, the OS will invoke the patcher's paint routine, which will dispatch to all of the boxes inside the invalid area according to the current Z-order of all the boxes. Boxes that are in the background are drawn first, so that any transparent or semi-transparent boxes can be drawn on top of them. In addition, unless you specify otherwise, the last drawn image of a box is cached in a buffer, so that your paint method will only be called when you explicitly invalidate your object's content with <a class="el" href="group__jbox.html#ga92b553f8adc9994553590bbbcfd7e49d" title="Request that your object/box be re-drawn by Max. ">jbox_redraw()</a>. In other words, you can't count on "global patcher drawing" to invoke your paint method.</p>
<p>The basic strategy you'll want to use in thinking about redrawing is that you will set internal state in other methods, then call <a class="el" href="group__jbox.html#ga92b553f8adc9994553590bbbcfd7e49d" title="Request that your object/box be re-drawn by Max. ">jbox_redraw()</a>. The paint method will read the internal state and adjust its drawing appropriately. You'll see this strategy used in the uisimp object as it tracks the mouse.</p>
<h1><a class="anchor" id="chapter_ui_anatomy_paint"></a>
The Paint Method</h1>
<p>Your object's paint method uses the jgraphics API to draw. The header file, jgraphics.h, provides a description of each of the routines in the API. Here we will only discuss general principles and features of drawing with uisimp's relatively simple paint method. There is also a jgraphics example UI object that contains a number of functions showing how various drawing tasks can be performed.</p>
<p>Drawing in Max is resolution-independent. The "size" of your object's rectangle is always the pixel size when the patcher is scaled to 100% regardless of the zoom level, and any magnification or size reduction to the actual screen is automatically handled by matrix transforms. Another thing that is handled automatically for you is drawing to multiple views. If a patcher is invisible (i.e., a subpatcher that has not been double-clicked), it does not have any views. But if it is visible, a patcher can have many patcherviews. If your UI object box is in a patcher with multiple views open, your paint method will be called once for each view, and will be passed different a patcherview object each time. For most objects, this will pose few problems, but for objects to work properly when there are anywhere from zero to ten views open, they cannot change their internal state in the paint method, they can only read it. As an example, if your object had a boolean "painted" field in its structure that would be set when the paint method had finished, it would not work properly in the cases where the box was invisible or where it was shown in multiple patcher views, because it would either be set zero or more than once.</p>
<p>The first step for any paint method is to obtain the <a class="el" href="group__jgraphics.html#ga4bf27bd7e21a59a427481b909d4656e7" title="An instance of a jgraphics drawing context. ">t_jgraphics</a> object from the patcherview object passed to the paint method. The patcherview is an opaque <a class="el" href="structt__object.html" title="The structure for the head of any object which wants to have inlets or outlets, or support attributes...">t_object</a> that you will use to access information about your box's rectangle and its graphics context. A patcherview is not the same thing as a patcher; as mentioned above, there could be more than one patcherview for a patcher if it has multiple views open.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> uisimp_paint(t_uisimp *x, <a class="code" href="structt__object.html">t_object</a> *patcherview)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structt__rect.html">t_rect</a> rect;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__jgraphics.html#ga4bf27bd7e21a59a427481b909d4656e7">t_jgraphics</a> *g = (<a class="code" href="group__jgraphics.html#ga4bf27bd7e21a59a427481b909d4656e7">t_jgraphics</a>*) <a class="code" href="group__jpatcherview.html#ga221544b77a5371897c96f2e94ae49c82">patcherview_get_jgraphics</a>(patcherview);     <span class="comment">// obtain graphics context</span></div>
</div><!-- fragment --><p>After obtaining the <a class="el" href="group__jgraphics.html#ga4bf27bd7e21a59a427481b909d4656e7" title="An instance of a jgraphics drawing context. ">t_jgraphics</a> object, the next thing that you'll need to do is determine the rectangle of your box. A view of a patcher may be in either patching or presentation mode. Since each mode can have its own rectangle, it is necessary to use the patcherview to obtain the rectangle for your object.</p>
<div class="fragment"><div class="line"><a class="code" href="group__jbox.html#gab47a7fa918c470f60f0789baafaa7b4b">jbox_get_rect_for_view</a>((<a class="code" href="structt__object.html">t_object</a> *)x, patcherview, &amp;rect);</div>
</div><!-- fragment --><p>The <a class="el" href="structt__rect.html" title="Coordinates for specifying a rectangular region. ">t_rect</a> structure specifies a rectangle using the x and y coordinates of the top left corner, along with the width and height. However, the coordinates of the <a class="el" href="group__jgraphics.html#ga4bf27bd7e21a59a427481b909d4656e7" title="An instance of a jgraphics drawing context. ">t_jgraphics</a> you'll be using to draw into always begin at 0 for the top left corner, so you'll only care about the width and height, at least for drawing.</p>
<p>The first thing we'll draw is just an outline of our box using the value of the outline color attribute. First we'll set the color we want to use, then make a rectangular path, then finally we'll stroke the path we've made.</p>
<p>With calls such as <a class="el" href="group__jgraphics.html#ga01f63358f24616678d69721d7d505e74" title="Add a closed rectangle path in the context. ">jgraphics_rectangle()</a>, the rectangular shape is added to the existing path. The initial path is empty, and after calling jgraphics_stroke() or jgraphics_fill(), the path is again cleared. (If you want to retain the path, you can use the jgraphics_stroke_preserve() and jgraphics_fill_preserve variants().)</p>
<div class="fragment"><div class="line">jgraphics_set_source_jrgba(g, &amp;x-&gt;u_outline);</div>
<div class="line">jgraphics_set_line_width(g, 1.);</div>
<div class="line"><a class="code" href="group__jgraphics.html#ga01f63358f24616678d69721d7d505e74">jgraphics_rectangle</a>(g, 0., 0., rect.<a class="code" href="structt__rect.html#ab847deccce398dc299128046647413d9">width</a>, rect.<a class="code" href="structt__rect.html#aca22f5c74590cfbbc24c75dd432e5f75">height</a>);</div>
<div class="line">jgraphics_stroke(g);</div>
</div><!-- fragment --><p>You do not need to destroy the path before your paint method is finished. This will be done for you, but the fact that the path does not survive after the paint method is finished means you can't make a path and then store it without copying it first. Such a strategy is not recommended in any case, since your object's rectangle might change unpredictably from one paint method invocation to the next, which will likely cause your path to be the wrong shape or size.</p>
<p>The next feature of the paint method is to draw an inner outline if the mouse is moved over the box. Detecting the mouse's presence over the box happens in the mouseenter / mouseleave methods described below &ndash; but essentially, we know that the mouse is over our object if the u_mouseover has been set by these mouse tracking methods.</p>
<p>To draw a rectangle that is inset by one pixel from the box rectangle, we use the rectangle starting at 1, 1 with a width of the box width - 2 and a height of the box height - 2.</p>
<div class="fragment"><div class="line"><span class="comment">// paint &quot;inner highlight&quot; to indicate mouseover</span></div>
<div class="line"><span class="keywordflow">if</span> (x-&gt;u_mouseover &amp;&amp; !x-&gt;u_mousedowninside) {</div>
<div class="line">    jgraphics_set_source_jrgba(g, &amp;x-&gt;u_hilite);</div>
<div class="line">    jgraphics_set_line_width(g, 1.);</div>
<div class="line">    <a class="code" href="group__jgraphics.html#ga01f63358f24616678d69721d7d505e74">jgraphics_rectangle</a>(g, 1., 1., rect.<a class="code" href="structt__rect.html#ab847deccce398dc299128046647413d9">width</a> - 2, rect.<a class="code" href="structt__rect.html#aca22f5c74590cfbbc24c75dd432e5f75">height</a> - 2);</div>
<div class="line">    jgraphics_stroke(g);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Some similar code provides the ability to show the highlight color when the user is about to check (turn on) the toggle:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (x-&gt;u_mousedowninside &amp;&amp; !x-&gt;u_state) {      <span class="comment">// paint hilite color</span></div>
<div class="line">    jgraphics_set_source_jrgba(g, &amp;x-&gt;u_hilite);</div>
<div class="line">    <a class="code" href="group__jgraphics.html#ga01f63358f24616678d69721d7d505e74">jgraphics_rectangle</a>(g, 1., 1., rect.<a class="code" href="structt__rect.html#ab847deccce398dc299128046647413d9">width</a> - 2, rect.<a class="code" href="structt__rect.html#aca22f5c74590cfbbc24c75dd432e5f75">height</a> - 2);</div>
<div class="line">    jgraphics_fill(g);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Finally, we paint a square in the middle of the object if the toggle state is non-zero to indicate that the box has been checked. Here we are filling a path instead of stroking it. Note also that we use the call <a class="el" href="group__jbox.html#ga03c4056e731c28342a8ee17e5b86558f" title="Retrieve a box&#39;s &#39;color&#39; attribute. ">jbox_get_color()</a> to get the "standard" color of our object that is stored inside the <a class="el" href="structt__jbox.html" title="The t_jbox struct provides the header for a Max user-interface object. ">t_jbox</a>. As we've specified by using the <a class="el" href="group__jbox.html#ga14cb28210886cfe0df0c34f71338faf8" title="support the &quot;color&quot; method for color customization ">JBOX_COLOR</a> flag for jbox_initclass() in our initialization routine, the color obtained by <a class="el" href="group__jbox.html#ga03c4056e731c28342a8ee17e5b86558f" title="Retrieve a box&#39;s &#39;color&#39; attribute. ">jbox_get_color()</a> for the "check" (really just a square of solid color) is the one the user can change with the Color... item in the Object menu.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (x-&gt;u_state) {</div>
<div class="line">    <a class="code" href="structt__jrgba.html">t_jrgba</a> col;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__jbox.html#ga03c4056e731c28342a8ee17e5b86558f">jbox_get_color</a>((<a class="code" href="structt__object.html">t_object</a> *)x, &amp;col);</div>
<div class="line">    jgraphics_set_source_jrgba(g, &amp;col);</div>
<div class="line">    <span class="keywordflow">if</span> (x-&gt;u_mousedowninside)       <span class="comment">// make rect bigger if mouse is down and we are unchecking</span></div>
<div class="line">        <a class="code" href="group__jgraphics.html#ga01f63358f24616678d69721d7d505e74">jgraphics_rectangle</a>(g, 3., 3., rect.<a class="code" href="structt__rect.html#ab847deccce398dc299128046647413d9">width</a> - 6, rect.<a class="code" href="structt__rect.html#aca22f5c74590cfbbc24c75dd432e5f75">height</a> - 6);</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">        <a class="code" href="group__jgraphics.html#ga01f63358f24616678d69721d7d505e74">jgraphics_rectangle</a>(g, 4., 4., rect.<a class="code" href="structt__rect.html#ab847deccce398dc299128046647413d9">width</a> - 8, rect.<a class="code" href="structt__rect.html#aca22f5c74590cfbbc24c75dd432e5f75">height</a> - 8);</div>
<div class="line">    jgraphics_fill(g);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Clearly, a quick perusal of the jgraphics.h header file will demonstrate that there is much more to drawing than we've discussed here. But the main purpose of the uisimp paint method is to show how to implement "dynamic" graphics that follow the mouse. Now we'll see the mouse tracking side of the story.</p>
<h1><a class="anchor" id="chapter_ui_anatomy_mouse"></a>
Handling Mouse Gestures</h1>
<p>When the mouse is clicked, dragged, released, or moved inside its box, your object will receive messages. In the uisimp example we've defined methods for most of the mouse gesture messages available, and we've implemented them to change internal state in the object, then call <a class="el" href="group__jbox.html#ga92b553f8adc9994553590bbbcfd7e49d" title="Request that your object/box be re-drawn by Max. ">jbox_redraw()</a> to repaint the object to reflect the new state. This strategy produces a "dynamic" appearance of a gadget users associate with a typical graphical interface &ndash; in this case a toggle checkbox.</p>
<p>All mouse gesture methods are declared in the same way:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> myobect_mouse(t_myobject *x, <a class="code" href="structt__object.html">t_object</a> *patcherview, <a class="code" href="structt__pt.html">t_pt</a> pt, <span class="keywordtype">long</span> modifiers);</div>
</div><!-- fragment --><p>Let's first look at the most commonly implemented mouse gesture handler, the mousedown method that responds to an initial click on the object. As you can see, it is very simple; it merely sets u_mousedowninside to true, then calls <a class="el" href="group__jbox.html#ga92b553f8adc9994553590bbbcfd7e49d" title="Request that your object/box be re-drawn by Max. ">jbox_redraw()</a>, causing the box to be repainted. We've defined this toggle not to change the actual state until the mouse is released (unlike the standard Max toggle object), but we do want to give the user some feedback on the initial mouse down that something is going to happen. If you look back at the paint method, you can see that u_mousedowninside is used to change the way the object is painted to give it a "pending state change" appearance that will be finalized when the mouse is released inside the box.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> uisimp_mousedown(t_uisimp *x, <a class="code" href="structt__object.html">t_object</a> *patcherview, <a class="code" href="structt__pt.html">t_pt</a> pt, <span class="keywordtype">long</span> modifiers)</div>
<div class="line">{</div>
<div class="line">    x-&gt;u_mousedowninside = <span class="keyword">true</span>;    <span class="comment">// wouldn&#39;t get a click unless it was inside the box</span></div>
<div class="line">    <a class="code" href="group__jbox.html#ga92b553f8adc9994553590bbbcfd7e49d">jbox_redraw</a>((<a class="code" href="structt__jbox.html">t_jbox</a> *)x);</div>
<div class="line">}</div>
</div><!-- fragment --><p>If we test the mouse position to ensure that it is inside the box when it is released, we provide the opportunity for the user to cancel the act of toggling the state of the object by moving the cursor outside of the box before releasing the button. To provide feedback to the user that this is going to happen, we've implemented a mousedrag method that performs this test and redraws the object if the "mouse inside" condition has changed from its previous state. The mousedrag message will be sent to your object as long as the mouse button is still down after an initial click and the cursor has moved, even if the cursor moves outside of the boundaries of your object's box.</p>
<p>Note that, as with the paint method, we use the patcherview to get the current box rectangle. We can then test the point we are given to see if it is inside or outside the box.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> uisimp_mousedrag(t_uisimp *x, <a class="code" href="structt__object.html">t_object</a> *patcherview, <a class="code" href="structt__pt.html">t_pt</a> pt, <span class="keywordtype">long</span> modifiers)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structt__rect.html">t_rect</a> rect;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// test to see if mouse is still inside the object</span></div>
<div class="line">    <a class="code" href="group__jbox.html#gab47a7fa918c470f60f0789baafaa7b4b">jbox_get_rect_for_view</a>((<a class="code" href="structt__object.html">t_object</a> *)x, patcherview, &amp;rect);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// redraw if changed</span></div>
<div class="line">    <span class="keywordflow">if</span> (pt.<a class="code" href="structt__pt.html#abd1171389dfefa1b2cfc94c99e758936">x</a> &gt;= 0 &amp;&amp; pt.<a class="code" href="structt__pt.html#abd1171389dfefa1b2cfc94c99e758936">x</a> &lt;= rect.<a class="code" href="structt__rect.html#ab847deccce398dc299128046647413d9">width</a> &amp;&amp; pt.<a class="code" href="structt__pt.html#a1876ee367c9ff280c0710918d4ce8d3b">y</a> &gt;= 0 &amp;&amp; pt.<a class="code" href="structt__pt.html#a1876ee367c9ff280c0710918d4ce8d3b">y</a> &lt;= rect.<a class="code" href="structt__rect.html#aca22f5c74590cfbbc24c75dd432e5f75">height</a>) {</div>
<div class="line">        <span class="keywordflow">if</span> (!x-&gt;u_mousedowninside) {</div>
<div class="line">            x-&gt;u_mousedowninside = <span class="keyword">true</span>;</div>
<div class="line">            <a class="code" href="group__jbox.html#ga92b553f8adc9994553590bbbcfd7e49d">jbox_redraw</a>((<a class="code" href="structt__jbox.html">t_jbox</a> *)x);</div>
<div class="line">        }</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">if</span> (x-&gt;u_mousedowninside) {</div>
<div class="line">            x-&gt;u_mousedowninside = <span class="keyword">false</span>;</div>
<div class="line">            <a class="code" href="group__jbox.html#ga92b553f8adc9994553590bbbcfd7e49d">jbox_redraw</a>((<a class="code" href="structt__jbox.html">t_jbox</a> *)x);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Our mouseup method uses the last value of u_mousedowninside as the determining factor for whether to toggle the object's internal state. If u_mousedowninside is false, no state change happens. But if it is true, the state changes and the new state value is sent out the object's outlet (inside uisimp_bang()).</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (x-&gt;u_mousedowninside) {</div>
<div class="line">    x-&gt;u_state = !x-&gt;u_state;</div>
<div class="line">    uisimp_bang(x);</div>
<div class="line">    x-&gt;u_mousedowninside = <span class="keyword">false</span>;</div>
<div class="line">    <a class="code" href="group__jbox.html#ga92b553f8adc9994553590bbbcfd7e49d">jbox_redraw</a>((<a class="code" href="structt__jbox.html">t_jbox</a> *)x);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Finally, we've implemented mouseenter, mousemove, and mouseleave methods to provide another level of "mouse over" style highlighting for the object. Rather than changing u_mousedowninside, a u_mouseover field is set when the mouseenter message is received, and cleared when the mouseleave method is received. And again, after this variable is manipulated, we repaint the box with <a class="el" href="group__jbox.html#ga92b553f8adc9994553590bbbcfd7e49d" title="Request that your object/box be re-drawn by Max. ">jbox_redraw()</a>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> uisimp_mouseenter(t_uisimp *x, <a class="code" href="structt__object.html">t_object</a> *patcherview, <a class="code" href="structt__pt.html">t_pt</a> pt, <span class="keywordtype">long</span> modifiers)</div>
<div class="line">{</div>
<div class="line">    x-&gt;u_mouseover = <span class="keyword">true</span>;</div>
<div class="line">    <a class="code" href="group__jbox.html#ga92b553f8adc9994553590bbbcfd7e49d">jbox_redraw</a>((<a class="code" href="structt__jbox.html">t_jbox</a> *)x);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> uisimp_mouseleave(t_uisimp *x, <a class="code" href="structt__object.html">t_object</a> *patcherview, <a class="code" href="structt__pt.html">t_pt</a> pt, <span class="keywordtype">long</span> modifiers)</div>
<div class="line">{</div>
<div class="line">    x-&gt;u_mouseover = <span class="keyword">false</span>;</div>
<div class="line">    <a class="code" href="group__jbox.html#ga92b553f8adc9994553590bbbcfd7e49d">jbox_redraw</a>((<a class="code" href="structt__jbox.html">t_jbox</a> *)x);</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="chapter_ui_anatomy_freeing"></a>
Freeing a UI Object</h1>
<p>If your object has created any clocks or otherwise allocated memory that should be freed when the object goes away, you should handle this in the free routine. But, most importantly, you must call the function <a class="el" href="group__jbox.html#ga769cbf2dd8ebf22ac21e9df271c61704" title="Tear down your UI object&#39;s t_jbox member. ">jbox_free()</a>. If your UI object doesn't need to do anything special in its free routine, you can pass <a class="el" href="group__jbox.html#ga769cbf2dd8ebf22ac21e9df271c61704" title="Tear down your UI object&#39;s t_jbox member. ">jbox_free()</a> as the free routine argument to <a class="el" href="group__class.html#ga3450d7e28cb57dc3819486ff49f019c7" title="Initializes a class by informing Max of its name, instance creation and free functions, size and argument types. ">class_new()</a> in your initialization routine. We chose not to do this, since having an actual function permits easy modification should some memory need to be freed at some point in the future evolution of the object.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> uisimp_free(t_uisimp *x)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="group__jbox.html#ga769cbf2dd8ebf22ac21e9df271c61704">jbox_free</a>((<a class="code" href="structt__jbox.html">t_jbox</a> *)x);</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
		<div id="c74footer">
			&nbsp;&nbsp;Copyright &copy; 2013, <a href="http://www.cycling74.com/">Cycling '74</a>
		</div>
	</body>
</html>
